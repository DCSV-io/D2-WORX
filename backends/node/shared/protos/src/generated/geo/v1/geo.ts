// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: geo/v1/geo.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { D2ResultProto } from "../../common/v1/d2_result";
import { Timestamp } from "../../google/protobuf/timestamp";

export const protobufPackage = "d2.geo.v1";

export interface RequestReferenceDataUpdateRequest {
}

export interface RequestReferenceDataUpdateResponse {
  result: D2ResultProto | undefined;
  data: RequestReferenceDataUpdateData | undefined;
}

export interface RequestReferenceDataUpdateData {
  version: string;
}

export interface GetReferenceDataRequest {
}

export interface GetReferenceDataResponse {
  result: D2ResultProto | undefined;
  data: GeoRefData | undefined;
}

export interface GeoRefData {
  /** Semantic version of the reference data. */
  version: string;
  /** Timestamp of the last update. */
  updatedAt:
    | Date
    | undefined;
  /** Key is iso_3166_1_alpha_2_code. */
  countries: { [key: string]: CountryDTO };
  /** Key is iso_3166_2_code. */
  subdivisions: { [key: string]: SubdivisionDTO };
  /** Key is iso_4217_alpha_code. */
  currencies: { [key: string]: CurrencyDTO };
  /** Key is iso_639_1_code. */
  languages: { [key: string]: LanguageDTO };
  /** Key is ietf_bcp_47_tag. */
  locales: { [key: string]: LocaleDTO };
  /** Key is short_code. */
  geopoliticalEntities: { [key: string]: GeopoliticalEntityDTO };
}

export interface GeoRefData_CountriesEntry {
  key: string;
  value: CountryDTO | undefined;
}

export interface GeoRefData_SubdivisionsEntry {
  key: string;
  value: SubdivisionDTO | undefined;
}

export interface GeoRefData_CurrenciesEntry {
  key: string;
  value: CurrencyDTO | undefined;
}

export interface GeoRefData_LanguagesEntry {
  key: string;
  value: LanguageDTO | undefined;
}

export interface GeoRefData_LocalesEntry {
  key: string;
  value: LocaleDTO | undefined;
}

export interface GeoRefData_GeopoliticalEntitiesEntry {
  key: string;
  value: GeopoliticalEntityDTO | undefined;
}

export interface FindWhoIsRequest {
  requests: FindWhoIsKeys[];
}

export interface FindWhoIsKeys {
  ipAddress: string;
  fingerprint: string;
}

export interface FindWhoIsResponse {
  result: D2ResultProto | undefined;
  data: FindWhoIsData[];
}

export interface FindWhoIsData {
  key: FindWhoIsKeys | undefined;
  whois: WhoIsDTO | undefined;
}

export interface GetContactsRequest {
  ids: string[];
}

export interface GetContactsResponse {
  result:
    | D2ResultProto
    | undefined;
  /** Key is id. */
  data: { [key: string]: ContactDTO };
}

export interface GetContactsResponse_DataEntry {
  key: string;
  value: ContactDTO | undefined;
}

export interface GetContactsByExtKeysRequest {
  keys: GetContactsExtKeys[];
}

export interface GetContactsExtKeys {
  contextKey: string;
  relatedEntityId: string;
}

export interface GetContactsByExtKeysResponse {
  result: D2ResultProto | undefined;
  data: GetContactsByExtKeysData[];
}

export interface GetContactsByExtKeysData {
  key: GetContactsExtKeys | undefined;
  contacts: ContactDTO[];
}

export interface CreateContactsRequest {
  contactsToCreate: ContactToCreateDTO[];
}

export interface CreateContactsResponse {
  result: D2ResultProto | undefined;
  data: ContactDTO[];
}

export interface DeleteContactsRequest {
  ids: string[];
}

export interface DeleteContactsResponse {
  result: D2ResultProto | undefined;
  deleted: number;
}

export interface ContactToCreateDTO {
  createdAt: Date | undefined;
  contextKey: string;
  relatedEntityId: string;
  contactMethods: ContactMethodsDTO | undefined;
  personalDetails: PersonalDTO | undefined;
  professionalDetails:
    | ProfessionalDTO
    | undefined;
  /** Full location data or just hash_id to reference existing. */
  location: LocationDTO | undefined;
}

export interface CountryDTO {
  /** Primary key. */
  iso31661Alpha2Code: string;
  /** Unique keys. */
  iso31661Alpha3Code: string;
  iso31661NumericCode: string;
  /** Properties. */
  displayName: string;
  officialName: string;
  phoneNumberPrefix: string;
  phoneNumberFormat: string;
  /** Foreign keys. */
  sovereignIso31661Alpha2Code: string;
  primaryCurrencyIso4217AlphaCode: string;
  primaryLocaleIetfBcp47Tag: string;
  /** Navigation properties as lists of identifiers. */
  territoryIso31661Alpha2Codes: string[];
  /** One-to-many. */
  subdivisionIso31662Codes: string[];
  /** Many-to-many. */
  currencyIso4217AlphaCodes: string[];
  /** One-to-many. */
  localeIetfBcp47Tags: string[];
  /** Many-to-many. */
  geopoliticalEntityShortCodes: string[];
}

export interface SubdivisionDTO {
  /** Primary key. */
  iso31662Code: string;
  /** Properties. */
  shortCode: string;
  displayName: string;
  officialName: string;
  /** Foreign keys. */
  countryIso31661Alpha2Code: string;
}

export interface CurrencyDTO {
  /** Primary key. */
  iso4217AlphaCode: string;
  /** Unique keys. */
  iso4217NumericCode: string;
  /** Properties. */
  displayName: string;
  officialName: string;
  decimalPlaces: number;
  symbol: string;
  /** Navigation properties as lists of identifiers. */
  countryIso31661Alpha2Codes: string[];
}

export interface LanguageDTO {
  /** Primary key. */
  iso6391Code: string;
  /** Properties. */
  name: string;
  endonym: string;
}

export interface LocaleDTO {
  /** Primary key. */
  ietfBcp47Tag: string;
  /** Properties. */
  name: string;
  endonym: string;
  /** Foreign keys. */
  languageIso6391Code: string;
  countryIso31661Alpha2Code: string;
}

export interface GeopoliticalEntityDTO {
  /** Primary key. */
  shortCode: string;
  /** Properties. */
  name: string;
  type: string;
  /** Navigation properties as lists of identifiers. */
  countryIso31661Alpha2Codes: string[];
}

export interface CoordinatesDTO {
  latitude: number;
  longitude: number;
}

export interface StreetAddressDTO {
  line1: string;
  line2: string;
  line3: string;
}

export interface EmailAddressDTO {
  value: string;
  labels: string[];
}

export interface PhoneNumberDTO {
  value: string;
  labels: string[];
}

export interface PersonalDTO {
  title: string;
  firstName: string;
  preferredName: string;
  middleName: string;
  lastName: string;
  generationalSuffix: string;
  professionalCredentials: string[];
  dateOfBirth: string;
  biologicalSex: string;
}

export interface ProfessionalDTO {
  companyName: string;
  jobTitle: string;
  department: string;
  companyWebsite: string;
}

export interface ContactMethodsDTO {
  emails: EmailAddressDTO[];
  phoneNumbers: PhoneNumberDTO[];
}

export interface LocationDTO {
  hashId: string;
  coordinates: CoordinatesDTO | undefined;
  address: StreetAddressDTO | undefined;
  city: string;
  postalCode: string;
  subdivisionIso31662Code: string;
  countryIso31661Alpha2Code: string;
}

export interface WhoIsDTO {
  hashId: string;
  /** Content-addressable properties. */
  ipAddress: string;
  year: number;
  month: number;
  fingerprint: string;
  /** ASN properties. */
  asn: number;
  asName: string;
  asDomain: string;
  asType: string;
  /** Carrier properties. */
  carrierName: string;
  mcc: string;
  mnc: string;
  /** Change dates (ISO 8601 date strings). */
  asChanged: string;
  geoChanged: string;
  /** Network flags. */
  isAnonymous: boolean;
  isAnycast: boolean;
  isHosting: boolean;
  isMobile: boolean;
  isSatellite: boolean;
  isProxy: boolean;
  isRelay: boolean;
  isTor: boolean;
  isVpn: boolean;
  privacyName: string;
  /** Location data. */
  location: LocationDTO | undefined;
}

export interface ContactDTO {
  id: string;
  createdAt: Date | undefined;
  contextKey: string;
  relatedEntityId: string;
  contactMethods: ContactMethodsDTO | undefined;
  personalDetails: PersonalDTO | undefined;
  professionalDetails:
    | ProfessionalDTO
    | undefined;
  /** Full location data (null if no location). */
  location: LocationDTO | undefined;
}

function createBaseRequestReferenceDataUpdateRequest(): RequestReferenceDataUpdateRequest {
  return {};
}

export const RequestReferenceDataUpdateRequest: MessageFns<RequestReferenceDataUpdateRequest> = {
  encode(_: RequestReferenceDataUpdateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestReferenceDataUpdateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestReferenceDataUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RequestReferenceDataUpdateRequest {
    return {};
  },

  toJSON(_: RequestReferenceDataUpdateRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestReferenceDataUpdateRequest>, I>>(
    base?: I,
  ): RequestReferenceDataUpdateRequest {
    return RequestReferenceDataUpdateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestReferenceDataUpdateRequest>, I>>(
    _: I,
  ): RequestReferenceDataUpdateRequest {
    const message = createBaseRequestReferenceDataUpdateRequest();
    return message;
  },
};

function createBaseRequestReferenceDataUpdateResponse(): RequestReferenceDataUpdateResponse {
  return { result: undefined, data: undefined };
}

export const RequestReferenceDataUpdateResponse: MessageFns<RequestReferenceDataUpdateResponse> = {
  encode(message: RequestReferenceDataUpdateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      D2ResultProto.encode(message.result, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      RequestReferenceDataUpdateData.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestReferenceDataUpdateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestReferenceDataUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = D2ResultProto.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = RequestReferenceDataUpdateData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestReferenceDataUpdateResponse {
    return {
      result: isSet(object.result) ? D2ResultProto.fromJSON(object.result) : undefined,
      data: isSet(object.data) ? RequestReferenceDataUpdateData.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: RequestReferenceDataUpdateResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = D2ResultProto.toJSON(message.result);
    }
    if (message.data !== undefined) {
      obj.data = RequestReferenceDataUpdateData.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestReferenceDataUpdateResponse>, I>>(
    base?: I,
  ): RequestReferenceDataUpdateResponse {
    return RequestReferenceDataUpdateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestReferenceDataUpdateResponse>, I>>(
    object: I,
  ): RequestReferenceDataUpdateResponse {
    const message = createBaseRequestReferenceDataUpdateResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? D2ResultProto.fromPartial(object.result)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? RequestReferenceDataUpdateData.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseRequestReferenceDataUpdateData(): RequestReferenceDataUpdateData {
  return { version: "" };
}

export const RequestReferenceDataUpdateData: MessageFns<RequestReferenceDataUpdateData> = {
  encode(message: RequestReferenceDataUpdateData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestReferenceDataUpdateData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestReferenceDataUpdateData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestReferenceDataUpdateData {
    return { version: isSet(object.version) ? globalThis.String(object.version) : "" };
  },

  toJSON(message: RequestReferenceDataUpdateData): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestReferenceDataUpdateData>, I>>(base?: I): RequestReferenceDataUpdateData {
    return RequestReferenceDataUpdateData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestReferenceDataUpdateData>, I>>(
    object: I,
  ): RequestReferenceDataUpdateData {
    const message = createBaseRequestReferenceDataUpdateData();
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseGetReferenceDataRequest(): GetReferenceDataRequest {
  return {};
}

export const GetReferenceDataRequest: MessageFns<GetReferenceDataRequest> = {
  encode(_: GetReferenceDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReferenceDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReferenceDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetReferenceDataRequest {
    return {};
  },

  toJSON(_: GetReferenceDataRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetReferenceDataRequest>, I>>(base?: I): GetReferenceDataRequest {
    return GetReferenceDataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetReferenceDataRequest>, I>>(_: I): GetReferenceDataRequest {
    const message = createBaseGetReferenceDataRequest();
    return message;
  },
};

function createBaseGetReferenceDataResponse(): GetReferenceDataResponse {
  return { result: undefined, data: undefined };
}

export const GetReferenceDataResponse: MessageFns<GetReferenceDataResponse> = {
  encode(message: GetReferenceDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      D2ResultProto.encode(message.result, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      GeoRefData.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReferenceDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReferenceDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = D2ResultProto.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = GeoRefData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReferenceDataResponse {
    return {
      result: isSet(object.result) ? D2ResultProto.fromJSON(object.result) : undefined,
      data: isSet(object.data) ? GeoRefData.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: GetReferenceDataResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = D2ResultProto.toJSON(message.result);
    }
    if (message.data !== undefined) {
      obj.data = GeoRefData.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetReferenceDataResponse>, I>>(base?: I): GetReferenceDataResponse {
    return GetReferenceDataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetReferenceDataResponse>, I>>(object: I): GetReferenceDataResponse {
    const message = createBaseGetReferenceDataResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? D2ResultProto.fromPartial(object.result)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? GeoRefData.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseGeoRefData(): GeoRefData {
  return {
    version: "",
    updatedAt: undefined,
    countries: {},
    subdivisions: {},
    currencies: {},
    languages: {},
    locales: {},
    geopoliticalEntities: {},
  };
}

export const GeoRefData: MessageFns<GeoRefData> = {
  encode(message: GeoRefData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(18).fork()).join();
    }
    globalThis.Object.entries(message.countries).forEach(([key, value]: [string, CountryDTO]) => {
      GeoRefData_CountriesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    globalThis.Object.entries(message.subdivisions).forEach(([key, value]: [string, SubdivisionDTO]) => {
      GeoRefData_SubdivisionsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    globalThis.Object.entries(message.currencies).forEach(([key, value]: [string, CurrencyDTO]) => {
      GeoRefData_CurrenciesEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    globalThis.Object.entries(message.languages).forEach(([key, value]: [string, LanguageDTO]) => {
      GeoRefData_LanguagesEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    globalThis.Object.entries(message.locales).forEach(([key, value]: [string, LocaleDTO]) => {
      GeoRefData_LocalesEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    globalThis.Object.entries(message.geopoliticalEntities).forEach(([key, value]: [string, GeopoliticalEntityDTO]) => {
      GeoRefData_GeopoliticalEntitiesEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoRefData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoRefData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = GeoRefData_CountriesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.countries[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = GeoRefData_SubdivisionsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.subdivisions[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = GeoRefData_CurrenciesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.currencies[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = GeoRefData_LanguagesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.languages[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = GeoRefData_LocalesEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.locales[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = GeoRefData_GeopoliticalEntitiesEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.geopoliticalEntities[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoRefData {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      updatedAt: isSet(object.updatedAt)
        ? fromJsonTimestamp(object.updatedAt)
        : isSet(object.updated_at)
        ? fromJsonTimestamp(object.updated_at)
        : undefined,
      countries: isObject(object.countries)
        ? (globalThis.Object.entries(object.countries) as [string, any][]).reduce(
          (acc: { [key: string]: CountryDTO }, [key, value]: [string, any]) => {
            acc[key] = CountryDTO.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      subdivisions: isObject(object.subdivisions)
        ? (globalThis.Object.entries(object.subdivisions) as [string, any][]).reduce(
          (acc: { [key: string]: SubdivisionDTO }, [key, value]: [string, any]) => {
            acc[key] = SubdivisionDTO.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      currencies: isObject(object.currencies)
        ? (globalThis.Object.entries(object.currencies) as [string, any][]).reduce(
          (acc: { [key: string]: CurrencyDTO }, [key, value]: [string, any]) => {
            acc[key] = CurrencyDTO.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      languages: isObject(object.languages)
        ? (globalThis.Object.entries(object.languages) as [string, any][]).reduce(
          (acc: { [key: string]: LanguageDTO }, [key, value]: [string, any]) => {
            acc[key] = LanguageDTO.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      locales: isObject(object.locales)
        ? (globalThis.Object.entries(object.locales) as [string, any][]).reduce(
          (acc: { [key: string]: LocaleDTO }, [key, value]: [string, any]) => {
            acc[key] = LocaleDTO.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      geopoliticalEntities: isObject(object.geopoliticalEntities)
        ? (globalThis.Object.entries(object.geopoliticalEntities) as [string, any][]).reduce(
          (acc: { [key: string]: GeopoliticalEntityDTO }, [key, value]: [string, any]) => {
            acc[key] = GeopoliticalEntityDTO.fromJSON(value);
            return acc;
          },
          {},
        )
        : isObject(object.geopolitical_entities)
        ? (globalThis.Object.entries(object.geopolitical_entities) as [string, any][]).reduce(
          (acc: { [key: string]: GeopoliticalEntityDTO }, [key, value]: [string, any]) => {
            acc[key] = GeopoliticalEntityDTO.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: GeoRefData): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.countries) {
      const entries = globalThis.Object.entries(message.countries) as [string, CountryDTO][];
      if (entries.length > 0) {
        obj.countries = {};
        entries.forEach(([k, v]) => {
          obj.countries[k] = CountryDTO.toJSON(v);
        });
      }
    }
    if (message.subdivisions) {
      const entries = globalThis.Object.entries(message.subdivisions) as [string, SubdivisionDTO][];
      if (entries.length > 0) {
        obj.subdivisions = {};
        entries.forEach(([k, v]) => {
          obj.subdivisions[k] = SubdivisionDTO.toJSON(v);
        });
      }
    }
    if (message.currencies) {
      const entries = globalThis.Object.entries(message.currencies) as [string, CurrencyDTO][];
      if (entries.length > 0) {
        obj.currencies = {};
        entries.forEach(([k, v]) => {
          obj.currencies[k] = CurrencyDTO.toJSON(v);
        });
      }
    }
    if (message.languages) {
      const entries = globalThis.Object.entries(message.languages) as [string, LanguageDTO][];
      if (entries.length > 0) {
        obj.languages = {};
        entries.forEach(([k, v]) => {
          obj.languages[k] = LanguageDTO.toJSON(v);
        });
      }
    }
    if (message.locales) {
      const entries = globalThis.Object.entries(message.locales) as [string, LocaleDTO][];
      if (entries.length > 0) {
        obj.locales = {};
        entries.forEach(([k, v]) => {
          obj.locales[k] = LocaleDTO.toJSON(v);
        });
      }
    }
    if (message.geopoliticalEntities) {
      const entries = globalThis.Object.entries(message.geopoliticalEntities) as [string, GeopoliticalEntityDTO][];
      if (entries.length > 0) {
        obj.geopoliticalEntities = {};
        entries.forEach(([k, v]) => {
          obj.geopoliticalEntities[k] = GeopoliticalEntityDTO.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoRefData>, I>>(base?: I): GeoRefData {
    return GeoRefData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoRefData>, I>>(object: I): GeoRefData {
    const message = createBaseGeoRefData();
    message.version = object.version ?? "";
    message.updatedAt = object.updatedAt ?? undefined;
    message.countries = (globalThis.Object.entries(object.countries ?? {}) as [string, CountryDTO][]).reduce(
      (acc: { [key: string]: CountryDTO }, [key, value]: [string, CountryDTO]) => {
        if (value !== undefined) {
          acc[key] = CountryDTO.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.subdivisions = (globalThis.Object.entries(object.subdivisions ?? {}) as [string, SubdivisionDTO][]).reduce(
      (acc: { [key: string]: SubdivisionDTO }, [key, value]: [string, SubdivisionDTO]) => {
        if (value !== undefined) {
          acc[key] = SubdivisionDTO.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.currencies = (globalThis.Object.entries(object.currencies ?? {}) as [string, CurrencyDTO][]).reduce(
      (acc: { [key: string]: CurrencyDTO }, [key, value]: [string, CurrencyDTO]) => {
        if (value !== undefined) {
          acc[key] = CurrencyDTO.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.languages = (globalThis.Object.entries(object.languages ?? {}) as [string, LanguageDTO][]).reduce(
      (acc: { [key: string]: LanguageDTO }, [key, value]: [string, LanguageDTO]) => {
        if (value !== undefined) {
          acc[key] = LanguageDTO.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.locales = (globalThis.Object.entries(object.locales ?? {}) as [string, LocaleDTO][]).reduce(
      (acc: { [key: string]: LocaleDTO }, [key, value]: [string, LocaleDTO]) => {
        if (value !== undefined) {
          acc[key] = LocaleDTO.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.geopoliticalEntities =
      (globalThis.Object.entries(object.geopoliticalEntities ?? {}) as [string, GeopoliticalEntityDTO][]).reduce(
        (acc: { [key: string]: GeopoliticalEntityDTO }, [key, value]: [string, GeopoliticalEntityDTO]) => {
          if (value !== undefined) {
            acc[key] = GeopoliticalEntityDTO.fromPartial(value);
          }
          return acc;
        },
        {},
      );
    return message;
  },
};

function createBaseGeoRefData_CountriesEntry(): GeoRefData_CountriesEntry {
  return { key: "", value: undefined };
}

export const GeoRefData_CountriesEntry: MessageFns<GeoRefData_CountriesEntry> = {
  encode(message: GeoRefData_CountriesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      CountryDTO.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoRefData_CountriesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoRefData_CountriesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = CountryDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoRefData_CountriesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? CountryDTO.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GeoRefData_CountriesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = CountryDTO.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoRefData_CountriesEntry>, I>>(base?: I): GeoRefData_CountriesEntry {
    return GeoRefData_CountriesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoRefData_CountriesEntry>, I>>(object: I): GeoRefData_CountriesEntry {
    const message = createBaseGeoRefData_CountriesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? CountryDTO.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGeoRefData_SubdivisionsEntry(): GeoRefData_SubdivisionsEntry {
  return { key: "", value: undefined };
}

export const GeoRefData_SubdivisionsEntry: MessageFns<GeoRefData_SubdivisionsEntry> = {
  encode(message: GeoRefData_SubdivisionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SubdivisionDTO.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoRefData_SubdivisionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoRefData_SubdivisionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SubdivisionDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoRefData_SubdivisionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SubdivisionDTO.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GeoRefData_SubdivisionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SubdivisionDTO.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoRefData_SubdivisionsEntry>, I>>(base?: I): GeoRefData_SubdivisionsEntry {
    return GeoRefData_SubdivisionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoRefData_SubdivisionsEntry>, I>>(object: I): GeoRefData_SubdivisionsEntry {
    const message = createBaseGeoRefData_SubdivisionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SubdivisionDTO.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGeoRefData_CurrenciesEntry(): GeoRefData_CurrenciesEntry {
  return { key: "", value: undefined };
}

export const GeoRefData_CurrenciesEntry: MessageFns<GeoRefData_CurrenciesEntry> = {
  encode(message: GeoRefData_CurrenciesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      CurrencyDTO.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoRefData_CurrenciesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoRefData_CurrenciesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = CurrencyDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoRefData_CurrenciesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? CurrencyDTO.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GeoRefData_CurrenciesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = CurrencyDTO.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoRefData_CurrenciesEntry>, I>>(base?: I): GeoRefData_CurrenciesEntry {
    return GeoRefData_CurrenciesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoRefData_CurrenciesEntry>, I>>(object: I): GeoRefData_CurrenciesEntry {
    const message = createBaseGeoRefData_CurrenciesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? CurrencyDTO.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGeoRefData_LanguagesEntry(): GeoRefData_LanguagesEntry {
  return { key: "", value: undefined };
}

export const GeoRefData_LanguagesEntry: MessageFns<GeoRefData_LanguagesEntry> = {
  encode(message: GeoRefData_LanguagesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      LanguageDTO.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoRefData_LanguagesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoRefData_LanguagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = LanguageDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoRefData_LanguagesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? LanguageDTO.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GeoRefData_LanguagesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = LanguageDTO.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoRefData_LanguagesEntry>, I>>(base?: I): GeoRefData_LanguagesEntry {
    return GeoRefData_LanguagesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoRefData_LanguagesEntry>, I>>(object: I): GeoRefData_LanguagesEntry {
    const message = createBaseGeoRefData_LanguagesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? LanguageDTO.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGeoRefData_LocalesEntry(): GeoRefData_LocalesEntry {
  return { key: "", value: undefined };
}

export const GeoRefData_LocalesEntry: MessageFns<GeoRefData_LocalesEntry> = {
  encode(message: GeoRefData_LocalesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      LocaleDTO.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoRefData_LocalesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoRefData_LocalesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = LocaleDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoRefData_LocalesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? LocaleDTO.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GeoRefData_LocalesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = LocaleDTO.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoRefData_LocalesEntry>, I>>(base?: I): GeoRefData_LocalesEntry {
    return GeoRefData_LocalesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoRefData_LocalesEntry>, I>>(object: I): GeoRefData_LocalesEntry {
    const message = createBaseGeoRefData_LocalesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? LocaleDTO.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGeoRefData_GeopoliticalEntitiesEntry(): GeoRefData_GeopoliticalEntitiesEntry {
  return { key: "", value: undefined };
}

export const GeoRefData_GeopoliticalEntitiesEntry: MessageFns<GeoRefData_GeopoliticalEntitiesEntry> = {
  encode(message: GeoRefData_GeopoliticalEntitiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      GeopoliticalEntityDTO.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoRefData_GeopoliticalEntitiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoRefData_GeopoliticalEntitiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = GeopoliticalEntityDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoRefData_GeopoliticalEntitiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? GeopoliticalEntityDTO.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GeoRefData_GeopoliticalEntitiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = GeopoliticalEntityDTO.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoRefData_GeopoliticalEntitiesEntry>, I>>(
    base?: I,
  ): GeoRefData_GeopoliticalEntitiesEntry {
    return GeoRefData_GeopoliticalEntitiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoRefData_GeopoliticalEntitiesEntry>, I>>(
    object: I,
  ): GeoRefData_GeopoliticalEntitiesEntry {
    const message = createBaseGeoRefData_GeopoliticalEntitiesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? GeopoliticalEntityDTO.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseFindWhoIsRequest(): FindWhoIsRequest {
  return { requests: [] };
}

export const FindWhoIsRequest: MessageFns<FindWhoIsRequest> = {
  encode(message: FindWhoIsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requests) {
      FindWhoIsKeys.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindWhoIsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindWhoIsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requests.push(FindWhoIsKeys.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindWhoIsRequest {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => FindWhoIsKeys.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FindWhoIsRequest): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => FindWhoIsKeys.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindWhoIsRequest>, I>>(base?: I): FindWhoIsRequest {
    return FindWhoIsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindWhoIsRequest>, I>>(object: I): FindWhoIsRequest {
    const message = createBaseFindWhoIsRequest();
    message.requests = object.requests?.map((e) => FindWhoIsKeys.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFindWhoIsKeys(): FindWhoIsKeys {
  return { ipAddress: "", fingerprint: "" };
}

export const FindWhoIsKeys: MessageFns<FindWhoIsKeys> = {
  encode(message: FindWhoIsKeys, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipAddress !== "") {
      writer.uint32(10).string(message.ipAddress);
    }
    if (message.fingerprint !== "") {
      writer.uint32(18).string(message.fingerprint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindWhoIsKeys {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindWhoIsKeys();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fingerprint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindWhoIsKeys {
    return {
      ipAddress: isSet(object.ipAddress)
        ? globalThis.String(object.ipAddress)
        : isSet(object.ip_address)
        ? globalThis.String(object.ip_address)
        : "",
      fingerprint: isSet(object.fingerprint) ? globalThis.String(object.fingerprint) : "",
    };
  },

  toJSON(message: FindWhoIsKeys): unknown {
    const obj: any = {};
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.fingerprint !== "") {
      obj.fingerprint = message.fingerprint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindWhoIsKeys>, I>>(base?: I): FindWhoIsKeys {
    return FindWhoIsKeys.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindWhoIsKeys>, I>>(object: I): FindWhoIsKeys {
    const message = createBaseFindWhoIsKeys();
    message.ipAddress = object.ipAddress ?? "";
    message.fingerprint = object.fingerprint ?? "";
    return message;
  },
};

function createBaseFindWhoIsResponse(): FindWhoIsResponse {
  return { result: undefined, data: [] };
}

export const FindWhoIsResponse: MessageFns<FindWhoIsResponse> = {
  encode(message: FindWhoIsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      D2ResultProto.encode(message.result, writer.uint32(10).fork()).join();
    }
    for (const v of message.data) {
      FindWhoIsData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindWhoIsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindWhoIsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = D2ResultProto.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data.push(FindWhoIsData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindWhoIsResponse {
    return {
      result: isSet(object.result) ? D2ResultProto.fromJSON(object.result) : undefined,
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => FindWhoIsData.fromJSON(e)) : [],
    };
  },

  toJSON(message: FindWhoIsResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = D2ResultProto.toJSON(message.result);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => FindWhoIsData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindWhoIsResponse>, I>>(base?: I): FindWhoIsResponse {
    return FindWhoIsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindWhoIsResponse>, I>>(object: I): FindWhoIsResponse {
    const message = createBaseFindWhoIsResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? D2ResultProto.fromPartial(object.result)
      : undefined;
    message.data = object.data?.map((e) => FindWhoIsData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFindWhoIsData(): FindWhoIsData {
  return { key: undefined, whois: undefined };
}

export const FindWhoIsData: MessageFns<FindWhoIsData> = {
  encode(message: FindWhoIsData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      FindWhoIsKeys.encode(message.key, writer.uint32(10).fork()).join();
    }
    if (message.whois !== undefined) {
      WhoIsDTO.encode(message.whois, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindWhoIsData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindWhoIsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = FindWhoIsKeys.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.whois = WhoIsDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindWhoIsData {
    return {
      key: isSet(object.key) ? FindWhoIsKeys.fromJSON(object.key) : undefined,
      whois: isSet(object.whois) ? WhoIsDTO.fromJSON(object.whois) : undefined,
    };
  },

  toJSON(message: FindWhoIsData): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = FindWhoIsKeys.toJSON(message.key);
    }
    if (message.whois !== undefined) {
      obj.whois = WhoIsDTO.toJSON(message.whois);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindWhoIsData>, I>>(base?: I): FindWhoIsData {
    return FindWhoIsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindWhoIsData>, I>>(object: I): FindWhoIsData {
    const message = createBaseFindWhoIsData();
    message.key = (object.key !== undefined && object.key !== null) ? FindWhoIsKeys.fromPartial(object.key) : undefined;
    message.whois = (object.whois !== undefined && object.whois !== null)
      ? WhoIsDTO.fromPartial(object.whois)
      : undefined;
    return message;
  },
};

function createBaseGetContactsRequest(): GetContactsRequest {
  return { ids: [] };
}

export const GetContactsRequest: MessageFns<GetContactsRequest> = {
  encode(message: GetContactsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContactsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContactsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContactsRequest {
    return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: GetContactsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContactsRequest>, I>>(base?: I): GetContactsRequest {
    return GetContactsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContactsRequest>, I>>(object: I): GetContactsRequest {
    const message = createBaseGetContactsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetContactsResponse(): GetContactsResponse {
  return { result: undefined, data: {} };
}

export const GetContactsResponse: MessageFns<GetContactsResponse> = {
  encode(message: GetContactsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      D2ResultProto.encode(message.result, writer.uint32(10).fork()).join();
    }
    globalThis.Object.entries(message.data).forEach(([key, value]: [string, ContactDTO]) => {
      GetContactsResponse_DataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContactsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContactsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = D2ResultProto.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = GetContactsResponse_DataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.data[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContactsResponse {
    return {
      result: isSet(object.result) ? D2ResultProto.fromJSON(object.result) : undefined,
      data: isObject(object.data)
        ? (globalThis.Object.entries(object.data) as [string, any][]).reduce(
          (acc: { [key: string]: ContactDTO }, [key, value]: [string, any]) => {
            acc[key] = ContactDTO.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: GetContactsResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = D2ResultProto.toJSON(message.result);
    }
    if (message.data) {
      const entries = globalThis.Object.entries(message.data) as [string, ContactDTO][];
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = ContactDTO.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContactsResponse>, I>>(base?: I): GetContactsResponse {
    return GetContactsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContactsResponse>, I>>(object: I): GetContactsResponse {
    const message = createBaseGetContactsResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? D2ResultProto.fromPartial(object.result)
      : undefined;
    message.data = (globalThis.Object.entries(object.data ?? {}) as [string, ContactDTO][]).reduce(
      (acc: { [key: string]: ContactDTO }, [key, value]: [string, ContactDTO]) => {
        if (value !== undefined) {
          acc[key] = ContactDTO.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGetContactsResponse_DataEntry(): GetContactsResponse_DataEntry {
  return { key: "", value: undefined };
}

export const GetContactsResponse_DataEntry: MessageFns<GetContactsResponse_DataEntry> = {
  encode(message: GetContactsResponse_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ContactDTO.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContactsResponse_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContactsResponse_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ContactDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContactsResponse_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ContactDTO.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetContactsResponse_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ContactDTO.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContactsResponse_DataEntry>, I>>(base?: I): GetContactsResponse_DataEntry {
    return GetContactsResponse_DataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContactsResponse_DataEntry>, I>>(
    object: I,
  ): GetContactsResponse_DataEntry {
    const message = createBaseGetContactsResponse_DataEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ContactDTO.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGetContactsByExtKeysRequest(): GetContactsByExtKeysRequest {
  return { keys: [] };
}

export const GetContactsByExtKeysRequest: MessageFns<GetContactsByExtKeysRequest> = {
  encode(message: GetContactsByExtKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keys) {
      GetContactsExtKeys.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContactsByExtKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContactsByExtKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keys.push(GetContactsExtKeys.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContactsByExtKeysRequest {
    return {
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => GetContactsExtKeys.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetContactsByExtKeysRequest): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => GetContactsExtKeys.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContactsByExtKeysRequest>, I>>(base?: I): GetContactsByExtKeysRequest {
    return GetContactsByExtKeysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContactsByExtKeysRequest>, I>>(object: I): GetContactsByExtKeysRequest {
    const message = createBaseGetContactsByExtKeysRequest();
    message.keys = object.keys?.map((e) => GetContactsExtKeys.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetContactsExtKeys(): GetContactsExtKeys {
  return { contextKey: "", relatedEntityId: "" };
}

export const GetContactsExtKeys: MessageFns<GetContactsExtKeys> = {
  encode(message: GetContactsExtKeys, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contextKey !== "") {
      writer.uint32(10).string(message.contextKey);
    }
    if (message.relatedEntityId !== "") {
      writer.uint32(18).string(message.relatedEntityId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContactsExtKeys {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContactsExtKeys();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contextKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.relatedEntityId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContactsExtKeys {
    return {
      contextKey: isSet(object.contextKey)
        ? globalThis.String(object.contextKey)
        : isSet(object.context_key)
        ? globalThis.String(object.context_key)
        : "",
      relatedEntityId: isSet(object.relatedEntityId)
        ? globalThis.String(object.relatedEntityId)
        : isSet(object.related_entity_id)
        ? globalThis.String(object.related_entity_id)
        : "",
    };
  },

  toJSON(message: GetContactsExtKeys): unknown {
    const obj: any = {};
    if (message.contextKey !== "") {
      obj.contextKey = message.contextKey;
    }
    if (message.relatedEntityId !== "") {
      obj.relatedEntityId = message.relatedEntityId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContactsExtKeys>, I>>(base?: I): GetContactsExtKeys {
    return GetContactsExtKeys.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContactsExtKeys>, I>>(object: I): GetContactsExtKeys {
    const message = createBaseGetContactsExtKeys();
    message.contextKey = object.contextKey ?? "";
    message.relatedEntityId = object.relatedEntityId ?? "";
    return message;
  },
};

function createBaseGetContactsByExtKeysResponse(): GetContactsByExtKeysResponse {
  return { result: undefined, data: [] };
}

export const GetContactsByExtKeysResponse: MessageFns<GetContactsByExtKeysResponse> = {
  encode(message: GetContactsByExtKeysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      D2ResultProto.encode(message.result, writer.uint32(10).fork()).join();
    }
    for (const v of message.data) {
      GetContactsByExtKeysData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContactsByExtKeysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContactsByExtKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = D2ResultProto.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data.push(GetContactsByExtKeysData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContactsByExtKeysResponse {
    return {
      result: isSet(object.result) ? D2ResultProto.fromJSON(object.result) : undefined,
      data: globalThis.Array.isArray(object?.data)
        ? object.data.map((e: any) => GetContactsByExtKeysData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetContactsByExtKeysResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = D2ResultProto.toJSON(message.result);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => GetContactsByExtKeysData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContactsByExtKeysResponse>, I>>(base?: I): GetContactsByExtKeysResponse {
    return GetContactsByExtKeysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContactsByExtKeysResponse>, I>>(object: I): GetContactsByExtKeysResponse {
    const message = createBaseGetContactsByExtKeysResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? D2ResultProto.fromPartial(object.result)
      : undefined;
    message.data = object.data?.map((e) => GetContactsByExtKeysData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetContactsByExtKeysData(): GetContactsByExtKeysData {
  return { key: undefined, contacts: [] };
}

export const GetContactsByExtKeysData: MessageFns<GetContactsByExtKeysData> = {
  encode(message: GetContactsByExtKeysData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      GetContactsExtKeys.encode(message.key, writer.uint32(10).fork()).join();
    }
    for (const v of message.contacts) {
      ContactDTO.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContactsByExtKeysData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContactsByExtKeysData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = GetContactsExtKeys.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contacts.push(ContactDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContactsByExtKeysData {
    return {
      key: isSet(object.key) ? GetContactsExtKeys.fromJSON(object.key) : undefined,
      contacts: globalThis.Array.isArray(object?.contacts)
        ? object.contacts.map((e: any) => ContactDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetContactsByExtKeysData): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = GetContactsExtKeys.toJSON(message.key);
    }
    if (message.contacts?.length) {
      obj.contacts = message.contacts.map((e) => ContactDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContactsByExtKeysData>, I>>(base?: I): GetContactsByExtKeysData {
    return GetContactsByExtKeysData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContactsByExtKeysData>, I>>(object: I): GetContactsByExtKeysData {
    const message = createBaseGetContactsByExtKeysData();
    message.key = (object.key !== undefined && object.key !== null)
      ? GetContactsExtKeys.fromPartial(object.key)
      : undefined;
    message.contacts = object.contacts?.map((e) => ContactDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateContactsRequest(): CreateContactsRequest {
  return { contactsToCreate: [] };
}

export const CreateContactsRequest: MessageFns<CreateContactsRequest> = {
  encode(message: CreateContactsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.contactsToCreate) {
      ContactToCreateDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateContactsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateContactsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contactsToCreate.push(ContactToCreateDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateContactsRequest {
    return {
      contactsToCreate: globalThis.Array.isArray(object?.contactsToCreate)
        ? object.contactsToCreate.map((e: any) => ContactToCreateDTO.fromJSON(e))
        : globalThis.Array.isArray(object?.contacts_to_create)
        ? object.contacts_to_create.map((e: any) => ContactToCreateDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateContactsRequest): unknown {
    const obj: any = {};
    if (message.contactsToCreate?.length) {
      obj.contactsToCreate = message.contactsToCreate.map((e) => ContactToCreateDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateContactsRequest>, I>>(base?: I): CreateContactsRequest {
    return CreateContactsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateContactsRequest>, I>>(object: I): CreateContactsRequest {
    const message = createBaseCreateContactsRequest();
    message.contactsToCreate = object.contactsToCreate?.map((e) => ContactToCreateDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateContactsResponse(): CreateContactsResponse {
  return { result: undefined, data: [] };
}

export const CreateContactsResponse: MessageFns<CreateContactsResponse> = {
  encode(message: CreateContactsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      D2ResultProto.encode(message.result, writer.uint32(10).fork()).join();
    }
    for (const v of message.data) {
      ContactDTO.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateContactsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateContactsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = D2ResultProto.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data.push(ContactDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateContactsResponse {
    return {
      result: isSet(object.result) ? D2ResultProto.fromJSON(object.result) : undefined,
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => ContactDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: CreateContactsResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = D2ResultProto.toJSON(message.result);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => ContactDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateContactsResponse>, I>>(base?: I): CreateContactsResponse {
    return CreateContactsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateContactsResponse>, I>>(object: I): CreateContactsResponse {
    const message = createBaseCreateContactsResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? D2ResultProto.fromPartial(object.result)
      : undefined;
    message.data = object.data?.map((e) => ContactDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteContactsRequest(): DeleteContactsRequest {
  return { ids: [] };
}

export const DeleteContactsRequest: MessageFns<DeleteContactsRequest> = {
  encode(message: DeleteContactsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteContactsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteContactsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteContactsRequest {
    return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: DeleteContactsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteContactsRequest>, I>>(base?: I): DeleteContactsRequest {
    return DeleteContactsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteContactsRequest>, I>>(object: I): DeleteContactsRequest {
    const message = createBaseDeleteContactsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeleteContactsResponse(): DeleteContactsResponse {
  return { result: undefined, deleted: 0 };
}

export const DeleteContactsResponse: MessageFns<DeleteContactsResponse> = {
  encode(message: DeleteContactsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      D2ResultProto.encode(message.result, writer.uint32(10).fork()).join();
    }
    if (message.deleted !== 0) {
      writer.uint32(16).int32(message.deleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteContactsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteContactsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = D2ResultProto.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.deleted = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteContactsResponse {
    return {
      result: isSet(object.result) ? D2ResultProto.fromJSON(object.result) : undefined,
      deleted: isSet(object.deleted) ? globalThis.Number(object.deleted) : 0,
    };
  },

  toJSON(message: DeleteContactsResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = D2ResultProto.toJSON(message.result);
    }
    if (message.deleted !== 0) {
      obj.deleted = Math.round(message.deleted);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteContactsResponse>, I>>(base?: I): DeleteContactsResponse {
    return DeleteContactsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteContactsResponse>, I>>(object: I): DeleteContactsResponse {
    const message = createBaseDeleteContactsResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? D2ResultProto.fromPartial(object.result)
      : undefined;
    message.deleted = object.deleted ?? 0;
    return message;
  },
};

function createBaseContactToCreateDTO(): ContactToCreateDTO {
  return {
    createdAt: undefined,
    contextKey: "",
    relatedEntityId: "",
    contactMethods: undefined,
    personalDetails: undefined,
    professionalDetails: undefined,
    location: undefined,
  };
}

export const ContactToCreateDTO: MessageFns<ContactToCreateDTO> = {
  encode(message: ContactToCreateDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(10).fork()).join();
    }
    if (message.contextKey !== "") {
      writer.uint32(18).string(message.contextKey);
    }
    if (message.relatedEntityId !== "") {
      writer.uint32(26).string(message.relatedEntityId);
    }
    if (message.contactMethods !== undefined) {
      ContactMethodsDTO.encode(message.contactMethods, writer.uint32(34).fork()).join();
    }
    if (message.personalDetails !== undefined) {
      PersonalDTO.encode(message.personalDetails, writer.uint32(42).fork()).join();
    }
    if (message.professionalDetails !== undefined) {
      ProfessionalDTO.encode(message.professionalDetails, writer.uint32(50).fork()).join();
    }
    if (message.location !== undefined) {
      LocationDTO.encode(message.location, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContactToCreateDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContactToCreateDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contextKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.relatedEntityId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contactMethods = ContactMethodsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.personalDetails = PersonalDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.professionalDetails = ProfessionalDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.location = LocationDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContactToCreateDTO {
    return {
      createdAt: isSet(object.createdAt)
        ? fromJsonTimestamp(object.createdAt)
        : isSet(object.created_at)
        ? fromJsonTimestamp(object.created_at)
        : undefined,
      contextKey: isSet(object.contextKey)
        ? globalThis.String(object.contextKey)
        : isSet(object.context_key)
        ? globalThis.String(object.context_key)
        : "",
      relatedEntityId: isSet(object.relatedEntityId)
        ? globalThis.String(object.relatedEntityId)
        : isSet(object.related_entity_id)
        ? globalThis.String(object.related_entity_id)
        : "",
      contactMethods: isSet(object.contactMethods)
        ? ContactMethodsDTO.fromJSON(object.contactMethods)
        : isSet(object.contact_methods)
        ? ContactMethodsDTO.fromJSON(object.contact_methods)
        : undefined,
      personalDetails: isSet(object.personalDetails)
        ? PersonalDTO.fromJSON(object.personalDetails)
        : isSet(object.personal_details)
        ? PersonalDTO.fromJSON(object.personal_details)
        : undefined,
      professionalDetails: isSet(object.professionalDetails)
        ? ProfessionalDTO.fromJSON(object.professionalDetails)
        : isSet(object.professional_details)
        ? ProfessionalDTO.fromJSON(object.professional_details)
        : undefined,
      location: isSet(object.location) ? LocationDTO.fromJSON(object.location) : undefined,
    };
  },

  toJSON(message: ContactToCreateDTO): unknown {
    const obj: any = {};
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.contextKey !== "") {
      obj.contextKey = message.contextKey;
    }
    if (message.relatedEntityId !== "") {
      obj.relatedEntityId = message.relatedEntityId;
    }
    if (message.contactMethods !== undefined) {
      obj.contactMethods = ContactMethodsDTO.toJSON(message.contactMethods);
    }
    if (message.personalDetails !== undefined) {
      obj.personalDetails = PersonalDTO.toJSON(message.personalDetails);
    }
    if (message.professionalDetails !== undefined) {
      obj.professionalDetails = ProfessionalDTO.toJSON(message.professionalDetails);
    }
    if (message.location !== undefined) {
      obj.location = LocationDTO.toJSON(message.location);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContactToCreateDTO>, I>>(base?: I): ContactToCreateDTO {
    return ContactToCreateDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContactToCreateDTO>, I>>(object: I): ContactToCreateDTO {
    const message = createBaseContactToCreateDTO();
    message.createdAt = object.createdAt ?? undefined;
    message.contextKey = object.contextKey ?? "";
    message.relatedEntityId = object.relatedEntityId ?? "";
    message.contactMethods = (object.contactMethods !== undefined && object.contactMethods !== null)
      ? ContactMethodsDTO.fromPartial(object.contactMethods)
      : undefined;
    message.personalDetails = (object.personalDetails !== undefined && object.personalDetails !== null)
      ? PersonalDTO.fromPartial(object.personalDetails)
      : undefined;
    message.professionalDetails = (object.professionalDetails !== undefined && object.professionalDetails !== null)
      ? ProfessionalDTO.fromPartial(object.professionalDetails)
      : undefined;
    message.location = (object.location !== undefined && object.location !== null)
      ? LocationDTO.fromPartial(object.location)
      : undefined;
    return message;
  },
};

function createBaseCountryDTO(): CountryDTO {
  return {
    iso31661Alpha2Code: "",
    iso31661Alpha3Code: "",
    iso31661NumericCode: "",
    displayName: "",
    officialName: "",
    phoneNumberPrefix: "",
    phoneNumberFormat: "",
    sovereignIso31661Alpha2Code: "",
    primaryCurrencyIso4217AlphaCode: "",
    primaryLocaleIetfBcp47Tag: "",
    territoryIso31661Alpha2Codes: [],
    subdivisionIso31662Codes: [],
    currencyIso4217AlphaCodes: [],
    localeIetfBcp47Tags: [],
    geopoliticalEntityShortCodes: [],
  };
}

export const CountryDTO: MessageFns<CountryDTO> = {
  encode(message: CountryDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iso31661Alpha2Code !== "") {
      writer.uint32(10).string(message.iso31661Alpha2Code);
    }
    if (message.iso31661Alpha3Code !== "") {
      writer.uint32(18).string(message.iso31661Alpha3Code);
    }
    if (message.iso31661NumericCode !== "") {
      writer.uint32(26).string(message.iso31661NumericCode);
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.officialName !== "") {
      writer.uint32(42).string(message.officialName);
    }
    if (message.phoneNumberPrefix !== "") {
      writer.uint32(50).string(message.phoneNumberPrefix);
    }
    if (message.phoneNumberFormat !== "") {
      writer.uint32(58).string(message.phoneNumberFormat);
    }
    if (message.sovereignIso31661Alpha2Code !== "") {
      writer.uint32(66).string(message.sovereignIso31661Alpha2Code);
    }
    if (message.primaryCurrencyIso4217AlphaCode !== "") {
      writer.uint32(74).string(message.primaryCurrencyIso4217AlphaCode);
    }
    if (message.primaryLocaleIetfBcp47Tag !== "") {
      writer.uint32(82).string(message.primaryLocaleIetfBcp47Tag);
    }
    for (const v of message.territoryIso31661Alpha2Codes) {
      writer.uint32(90).string(v!);
    }
    for (const v of message.subdivisionIso31662Codes) {
      writer.uint32(98).string(v!);
    }
    for (const v of message.currencyIso4217AlphaCodes) {
      writer.uint32(106).string(v!);
    }
    for (const v of message.localeIetfBcp47Tags) {
      writer.uint32(114).string(v!);
    }
    for (const v of message.geopoliticalEntityShortCodes) {
      writer.uint32(122).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CountryDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCountryDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.iso31661Alpha2Code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.iso31661Alpha3Code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.iso31661NumericCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.officialName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.phoneNumberPrefix = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.phoneNumberFormat = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sovereignIso31661Alpha2Code = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.primaryCurrencyIso4217AlphaCode = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.primaryLocaleIetfBcp47Tag = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.territoryIso31661Alpha2Codes.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.subdivisionIso31662Codes.push(reader.string());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.currencyIso4217AlphaCodes.push(reader.string());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.localeIetfBcp47Tags.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.geopoliticalEntityShortCodes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CountryDTO {
    return {
      iso31661Alpha2Code: isSet(object.iso31661Alpha2Code)
        ? globalThis.String(object.iso31661Alpha2Code)
        : isSet(object.iso_3166_1_alpha_2_code)
        ? globalThis.String(object.iso_3166_1_alpha_2_code)
        : "",
      iso31661Alpha3Code: isSet(object.iso31661Alpha3Code)
        ? globalThis.String(object.iso31661Alpha3Code)
        : isSet(object.iso_3166_1_alpha_3_code)
        ? globalThis.String(object.iso_3166_1_alpha_3_code)
        : "",
      iso31661NumericCode: isSet(object.iso31661NumericCode)
        ? globalThis.String(object.iso31661NumericCode)
        : isSet(object.iso_3166_1_numeric_code)
        ? globalThis.String(object.iso_3166_1_numeric_code)
        : "",
      displayName: isSet(object.displayName)
        ? globalThis.String(object.displayName)
        : isSet(object.display_name)
        ? globalThis.String(object.display_name)
        : "",
      officialName: isSet(object.officialName)
        ? globalThis.String(object.officialName)
        : isSet(object.official_name)
        ? globalThis.String(object.official_name)
        : "",
      phoneNumberPrefix: isSet(object.phoneNumberPrefix)
        ? globalThis.String(object.phoneNumberPrefix)
        : isSet(object.phone_number_prefix)
        ? globalThis.String(object.phone_number_prefix)
        : "",
      phoneNumberFormat: isSet(object.phoneNumberFormat)
        ? globalThis.String(object.phoneNumberFormat)
        : isSet(object.phone_number_format)
        ? globalThis.String(object.phone_number_format)
        : "",
      sovereignIso31661Alpha2Code: isSet(object.sovereignIso31661Alpha2Code)
        ? globalThis.String(object.sovereignIso31661Alpha2Code)
        : isSet(object.sovereign_iso_3166_1_alpha_2_code)
        ? globalThis.String(object.sovereign_iso_3166_1_alpha_2_code)
        : "",
      primaryCurrencyIso4217AlphaCode: isSet(object.primaryCurrencyIso4217AlphaCode)
        ? globalThis.String(object.primaryCurrencyIso4217AlphaCode)
        : isSet(object.primary_currency_iso_4217_alpha_code)
        ? globalThis.String(object.primary_currency_iso_4217_alpha_code)
        : "",
      primaryLocaleIetfBcp47Tag: isSet(object.primaryLocaleIetfBcp47Tag)
        ? globalThis.String(object.primaryLocaleIetfBcp47Tag)
        : isSet(object.primary_locale_ietf_bcp_47_tag)
        ? globalThis.String(object.primary_locale_ietf_bcp_47_tag)
        : "",
      territoryIso31661Alpha2Codes: globalThis.Array.isArray(object?.territoryIso31661Alpha2Codes)
        ? object.territoryIso31661Alpha2Codes.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.territory_iso_3166_1_alpha_2_codes)
        ? object.territory_iso_3166_1_alpha_2_codes.map((e: any) => globalThis.String(e))
        : [],
      subdivisionIso31662Codes: globalThis.Array.isArray(object?.subdivisionIso31662Codes)
        ? object.subdivisionIso31662Codes.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.subdivision_iso_3166_2_codes)
        ? object.subdivision_iso_3166_2_codes.map((e: any) => globalThis.String(e))
        : [],
      currencyIso4217AlphaCodes: globalThis.Array.isArray(object?.currencyIso4217AlphaCodes)
        ? object.currencyIso4217AlphaCodes.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.currency_iso_4217_alpha_codes)
        ? object.currency_iso_4217_alpha_codes.map((e: any) => globalThis.String(e))
        : [],
      localeIetfBcp47Tags: globalThis.Array.isArray(object?.localeIetfBcp47Tags)
        ? object.localeIetfBcp47Tags.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.locale_ietf_bcp_47_tags)
        ? object.locale_ietf_bcp_47_tags.map((e: any) => globalThis.String(e))
        : [],
      geopoliticalEntityShortCodes: globalThis.Array.isArray(object?.geopoliticalEntityShortCodes)
        ? object.geopoliticalEntityShortCodes.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.geopolitical_entity_short_codes)
        ? object.geopolitical_entity_short_codes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CountryDTO): unknown {
    const obj: any = {};
    if (message.iso31661Alpha2Code !== "") {
      obj.iso31661Alpha2Code = message.iso31661Alpha2Code;
    }
    if (message.iso31661Alpha3Code !== "") {
      obj.iso31661Alpha3Code = message.iso31661Alpha3Code;
    }
    if (message.iso31661NumericCode !== "") {
      obj.iso31661NumericCode = message.iso31661NumericCode;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.officialName !== "") {
      obj.officialName = message.officialName;
    }
    if (message.phoneNumberPrefix !== "") {
      obj.phoneNumberPrefix = message.phoneNumberPrefix;
    }
    if (message.phoneNumberFormat !== "") {
      obj.phoneNumberFormat = message.phoneNumberFormat;
    }
    if (message.sovereignIso31661Alpha2Code !== "") {
      obj.sovereignIso31661Alpha2Code = message.sovereignIso31661Alpha2Code;
    }
    if (message.primaryCurrencyIso4217AlphaCode !== "") {
      obj.primaryCurrencyIso4217AlphaCode = message.primaryCurrencyIso4217AlphaCode;
    }
    if (message.primaryLocaleIetfBcp47Tag !== "") {
      obj.primaryLocaleIetfBcp47Tag = message.primaryLocaleIetfBcp47Tag;
    }
    if (message.territoryIso31661Alpha2Codes?.length) {
      obj.territoryIso31661Alpha2Codes = message.territoryIso31661Alpha2Codes;
    }
    if (message.subdivisionIso31662Codes?.length) {
      obj.subdivisionIso31662Codes = message.subdivisionIso31662Codes;
    }
    if (message.currencyIso4217AlphaCodes?.length) {
      obj.currencyIso4217AlphaCodes = message.currencyIso4217AlphaCodes;
    }
    if (message.localeIetfBcp47Tags?.length) {
      obj.localeIetfBcp47Tags = message.localeIetfBcp47Tags;
    }
    if (message.geopoliticalEntityShortCodes?.length) {
      obj.geopoliticalEntityShortCodes = message.geopoliticalEntityShortCodes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CountryDTO>, I>>(base?: I): CountryDTO {
    return CountryDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CountryDTO>, I>>(object: I): CountryDTO {
    const message = createBaseCountryDTO();
    message.iso31661Alpha2Code = object.iso31661Alpha2Code ?? "";
    message.iso31661Alpha3Code = object.iso31661Alpha3Code ?? "";
    message.iso31661NumericCode = object.iso31661NumericCode ?? "";
    message.displayName = object.displayName ?? "";
    message.officialName = object.officialName ?? "";
    message.phoneNumberPrefix = object.phoneNumberPrefix ?? "";
    message.phoneNumberFormat = object.phoneNumberFormat ?? "";
    message.sovereignIso31661Alpha2Code = object.sovereignIso31661Alpha2Code ?? "";
    message.primaryCurrencyIso4217AlphaCode = object.primaryCurrencyIso4217AlphaCode ?? "";
    message.primaryLocaleIetfBcp47Tag = object.primaryLocaleIetfBcp47Tag ?? "";
    message.territoryIso31661Alpha2Codes = object.territoryIso31661Alpha2Codes?.map((e) => e) || [];
    message.subdivisionIso31662Codes = object.subdivisionIso31662Codes?.map((e) => e) || [];
    message.currencyIso4217AlphaCodes = object.currencyIso4217AlphaCodes?.map((e) => e) || [];
    message.localeIetfBcp47Tags = object.localeIetfBcp47Tags?.map((e) => e) || [];
    message.geopoliticalEntityShortCodes = object.geopoliticalEntityShortCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseSubdivisionDTO(): SubdivisionDTO {
  return { iso31662Code: "", shortCode: "", displayName: "", officialName: "", countryIso31661Alpha2Code: "" };
}

export const SubdivisionDTO: MessageFns<SubdivisionDTO> = {
  encode(message: SubdivisionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iso31662Code !== "") {
      writer.uint32(10).string(message.iso31662Code);
    }
    if (message.shortCode !== "") {
      writer.uint32(18).string(message.shortCode);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.officialName !== "") {
      writer.uint32(34).string(message.officialName);
    }
    if (message.countryIso31661Alpha2Code !== "") {
      writer.uint32(42).string(message.countryIso31661Alpha2Code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubdivisionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubdivisionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.iso31662Code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shortCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.officialName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.countryIso31661Alpha2Code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubdivisionDTO {
    return {
      iso31662Code: isSet(object.iso31662Code)
        ? globalThis.String(object.iso31662Code)
        : isSet(object.iso_3166_2_code)
        ? globalThis.String(object.iso_3166_2_code)
        : "",
      shortCode: isSet(object.shortCode)
        ? globalThis.String(object.shortCode)
        : isSet(object.short_code)
        ? globalThis.String(object.short_code)
        : "",
      displayName: isSet(object.displayName)
        ? globalThis.String(object.displayName)
        : isSet(object.display_name)
        ? globalThis.String(object.display_name)
        : "",
      officialName: isSet(object.officialName)
        ? globalThis.String(object.officialName)
        : isSet(object.official_name)
        ? globalThis.String(object.official_name)
        : "",
      countryIso31661Alpha2Code: isSet(object.countryIso31661Alpha2Code)
        ? globalThis.String(object.countryIso31661Alpha2Code)
        : isSet(object.country_iso_3166_1_alpha_2_code)
        ? globalThis.String(object.country_iso_3166_1_alpha_2_code)
        : "",
    };
  },

  toJSON(message: SubdivisionDTO): unknown {
    const obj: any = {};
    if (message.iso31662Code !== "") {
      obj.iso31662Code = message.iso31662Code;
    }
    if (message.shortCode !== "") {
      obj.shortCode = message.shortCode;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.officialName !== "") {
      obj.officialName = message.officialName;
    }
    if (message.countryIso31661Alpha2Code !== "") {
      obj.countryIso31661Alpha2Code = message.countryIso31661Alpha2Code;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubdivisionDTO>, I>>(base?: I): SubdivisionDTO {
    return SubdivisionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubdivisionDTO>, I>>(object: I): SubdivisionDTO {
    const message = createBaseSubdivisionDTO();
    message.iso31662Code = object.iso31662Code ?? "";
    message.shortCode = object.shortCode ?? "";
    message.displayName = object.displayName ?? "";
    message.officialName = object.officialName ?? "";
    message.countryIso31661Alpha2Code = object.countryIso31661Alpha2Code ?? "";
    return message;
  },
};

function createBaseCurrencyDTO(): CurrencyDTO {
  return {
    iso4217AlphaCode: "",
    iso4217NumericCode: "",
    displayName: "",
    officialName: "",
    decimalPlaces: 0,
    symbol: "",
    countryIso31661Alpha2Codes: [],
  };
}

export const CurrencyDTO: MessageFns<CurrencyDTO> = {
  encode(message: CurrencyDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iso4217AlphaCode !== "") {
      writer.uint32(10).string(message.iso4217AlphaCode);
    }
    if (message.iso4217NumericCode !== "") {
      writer.uint32(18).string(message.iso4217NumericCode);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.officialName !== "") {
      writer.uint32(34).string(message.officialName);
    }
    if (message.decimalPlaces !== 0) {
      writer.uint32(40).int32(message.decimalPlaces);
    }
    if (message.symbol !== "") {
      writer.uint32(50).string(message.symbol);
    }
    for (const v of message.countryIso31661Alpha2Codes) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CurrencyDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCurrencyDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.iso4217AlphaCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.iso4217NumericCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.officialName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.decimalPlaces = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.countryIso31661Alpha2Codes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CurrencyDTO {
    return {
      iso4217AlphaCode: isSet(object.iso4217AlphaCode)
        ? globalThis.String(object.iso4217AlphaCode)
        : isSet(object.iso_4217_alpha_code)
        ? globalThis.String(object.iso_4217_alpha_code)
        : "",
      iso4217NumericCode: isSet(object.iso4217NumericCode)
        ? globalThis.String(object.iso4217NumericCode)
        : isSet(object.iso_4217_numeric_code)
        ? globalThis.String(object.iso_4217_numeric_code)
        : "",
      displayName: isSet(object.displayName)
        ? globalThis.String(object.displayName)
        : isSet(object.display_name)
        ? globalThis.String(object.display_name)
        : "",
      officialName: isSet(object.officialName)
        ? globalThis.String(object.officialName)
        : isSet(object.official_name)
        ? globalThis.String(object.official_name)
        : "",
      decimalPlaces: isSet(object.decimalPlaces)
        ? globalThis.Number(object.decimalPlaces)
        : isSet(object.decimal_places)
        ? globalThis.Number(object.decimal_places)
        : 0,
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      countryIso31661Alpha2Codes: globalThis.Array.isArray(object?.countryIso31661Alpha2Codes)
        ? object.countryIso31661Alpha2Codes.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.country_iso_3166_1_alpha_2_codes)
        ? object.country_iso_3166_1_alpha_2_codes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CurrencyDTO): unknown {
    const obj: any = {};
    if (message.iso4217AlphaCode !== "") {
      obj.iso4217AlphaCode = message.iso4217AlphaCode;
    }
    if (message.iso4217NumericCode !== "") {
      obj.iso4217NumericCode = message.iso4217NumericCode;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.officialName !== "") {
      obj.officialName = message.officialName;
    }
    if (message.decimalPlaces !== 0) {
      obj.decimalPlaces = Math.round(message.decimalPlaces);
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.countryIso31661Alpha2Codes?.length) {
      obj.countryIso31661Alpha2Codes = message.countryIso31661Alpha2Codes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CurrencyDTO>, I>>(base?: I): CurrencyDTO {
    return CurrencyDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CurrencyDTO>, I>>(object: I): CurrencyDTO {
    const message = createBaseCurrencyDTO();
    message.iso4217AlphaCode = object.iso4217AlphaCode ?? "";
    message.iso4217NumericCode = object.iso4217NumericCode ?? "";
    message.displayName = object.displayName ?? "";
    message.officialName = object.officialName ?? "";
    message.decimalPlaces = object.decimalPlaces ?? 0;
    message.symbol = object.symbol ?? "";
    message.countryIso31661Alpha2Codes = object.countryIso31661Alpha2Codes?.map((e) => e) || [];
    return message;
  },
};

function createBaseLanguageDTO(): LanguageDTO {
  return { iso6391Code: "", name: "", endonym: "" };
}

export const LanguageDTO: MessageFns<LanguageDTO> = {
  encode(message: LanguageDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iso6391Code !== "") {
      writer.uint32(10).string(message.iso6391Code);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.endonym !== "") {
      writer.uint32(26).string(message.endonym);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LanguageDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguageDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.iso6391Code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.endonym = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LanguageDTO {
    return {
      iso6391Code: isSet(object.iso6391Code)
        ? globalThis.String(object.iso6391Code)
        : isSet(object.iso_639_1_code)
        ? globalThis.String(object.iso_639_1_code)
        : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      endonym: isSet(object.endonym) ? globalThis.String(object.endonym) : "",
    };
  },

  toJSON(message: LanguageDTO): unknown {
    const obj: any = {};
    if (message.iso6391Code !== "") {
      obj.iso6391Code = message.iso6391Code;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.endonym !== "") {
      obj.endonym = message.endonym;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LanguageDTO>, I>>(base?: I): LanguageDTO {
    return LanguageDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LanguageDTO>, I>>(object: I): LanguageDTO {
    const message = createBaseLanguageDTO();
    message.iso6391Code = object.iso6391Code ?? "";
    message.name = object.name ?? "";
    message.endonym = object.endonym ?? "";
    return message;
  },
};

function createBaseLocaleDTO(): LocaleDTO {
  return { ietfBcp47Tag: "", name: "", endonym: "", languageIso6391Code: "", countryIso31661Alpha2Code: "" };
}

export const LocaleDTO: MessageFns<LocaleDTO> = {
  encode(message: LocaleDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ietfBcp47Tag !== "") {
      writer.uint32(10).string(message.ietfBcp47Tag);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.endonym !== "") {
      writer.uint32(26).string(message.endonym);
    }
    if (message.languageIso6391Code !== "") {
      writer.uint32(34).string(message.languageIso6391Code);
    }
    if (message.countryIso31661Alpha2Code !== "") {
      writer.uint32(42).string(message.countryIso31661Alpha2Code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocaleDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocaleDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ietfBcp47Tag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.endonym = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.languageIso6391Code = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.countryIso31661Alpha2Code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocaleDTO {
    return {
      ietfBcp47Tag: isSet(object.ietfBcp47Tag)
        ? globalThis.String(object.ietfBcp47Tag)
        : isSet(object.ietf_bcp_47_tag)
        ? globalThis.String(object.ietf_bcp_47_tag)
        : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      endonym: isSet(object.endonym) ? globalThis.String(object.endonym) : "",
      languageIso6391Code: isSet(object.languageIso6391Code)
        ? globalThis.String(object.languageIso6391Code)
        : isSet(object.language_iso_639_1_code)
        ? globalThis.String(object.language_iso_639_1_code)
        : "",
      countryIso31661Alpha2Code: isSet(object.countryIso31661Alpha2Code)
        ? globalThis.String(object.countryIso31661Alpha2Code)
        : isSet(object.country_iso_3166_1_alpha_2_code)
        ? globalThis.String(object.country_iso_3166_1_alpha_2_code)
        : "",
    };
  },

  toJSON(message: LocaleDTO): unknown {
    const obj: any = {};
    if (message.ietfBcp47Tag !== "") {
      obj.ietfBcp47Tag = message.ietfBcp47Tag;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.endonym !== "") {
      obj.endonym = message.endonym;
    }
    if (message.languageIso6391Code !== "") {
      obj.languageIso6391Code = message.languageIso6391Code;
    }
    if (message.countryIso31661Alpha2Code !== "") {
      obj.countryIso31661Alpha2Code = message.countryIso31661Alpha2Code;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocaleDTO>, I>>(base?: I): LocaleDTO {
    return LocaleDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocaleDTO>, I>>(object: I): LocaleDTO {
    const message = createBaseLocaleDTO();
    message.ietfBcp47Tag = object.ietfBcp47Tag ?? "";
    message.name = object.name ?? "";
    message.endonym = object.endonym ?? "";
    message.languageIso6391Code = object.languageIso6391Code ?? "";
    message.countryIso31661Alpha2Code = object.countryIso31661Alpha2Code ?? "";
    return message;
  },
};

function createBaseGeopoliticalEntityDTO(): GeopoliticalEntityDTO {
  return { shortCode: "", name: "", type: "", countryIso31661Alpha2Codes: [] };
}

export const GeopoliticalEntityDTO: MessageFns<GeopoliticalEntityDTO> = {
  encode(message: GeopoliticalEntityDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shortCode !== "") {
      writer.uint32(10).string(message.shortCode);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    for (const v of message.countryIso31661Alpha2Codes) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeopoliticalEntityDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeopoliticalEntityDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shortCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.countryIso31661Alpha2Codes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeopoliticalEntityDTO {
    return {
      shortCode: isSet(object.shortCode)
        ? globalThis.String(object.shortCode)
        : isSet(object.short_code)
        ? globalThis.String(object.short_code)
        : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      countryIso31661Alpha2Codes: globalThis.Array.isArray(object?.countryIso31661Alpha2Codes)
        ? object.countryIso31661Alpha2Codes.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.country_iso_3166_1_alpha_2_codes)
        ? object.country_iso_3166_1_alpha_2_codes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GeopoliticalEntityDTO): unknown {
    const obj: any = {};
    if (message.shortCode !== "") {
      obj.shortCode = message.shortCode;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.countryIso31661Alpha2Codes?.length) {
      obj.countryIso31661Alpha2Codes = message.countryIso31661Alpha2Codes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeopoliticalEntityDTO>, I>>(base?: I): GeopoliticalEntityDTO {
    return GeopoliticalEntityDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeopoliticalEntityDTO>, I>>(object: I): GeopoliticalEntityDTO {
    const message = createBaseGeopoliticalEntityDTO();
    message.shortCode = object.shortCode ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.countryIso31661Alpha2Codes = object.countryIso31661Alpha2Codes?.map((e) => e) || [];
    return message;
  },
};

function createBaseCoordinatesDTO(): CoordinatesDTO {
  return { latitude: 0, longitude: 0 };
}

export const CoordinatesDTO: MessageFns<CoordinatesDTO> = {
  encode(message: CoordinatesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.latitude !== 0) {
      writer.uint32(9).double(message.latitude);
    }
    if (message.longitude !== 0) {
      writer.uint32(17).double(message.longitude);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoordinatesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoordinatesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.latitude = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.longitude = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoordinatesDTO {
    return {
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
    };
  },

  toJSON(message: CoordinatesDTO): unknown {
    const obj: any = {};
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CoordinatesDTO>, I>>(base?: I): CoordinatesDTO {
    return CoordinatesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CoordinatesDTO>, I>>(object: I): CoordinatesDTO {
    const message = createBaseCoordinatesDTO();
    message.latitude = object.latitude ?? 0;
    message.longitude = object.longitude ?? 0;
    return message;
  },
};

function createBaseStreetAddressDTO(): StreetAddressDTO {
  return { line1: "", line2: "", line3: "" };
}

export const StreetAddressDTO: MessageFns<StreetAddressDTO> = {
  encode(message: StreetAddressDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.line1 !== "") {
      writer.uint32(10).string(message.line1);
    }
    if (message.line2 !== "") {
      writer.uint32(18).string(message.line2);
    }
    if (message.line3 !== "") {
      writer.uint32(26).string(message.line3);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreetAddressDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreetAddressDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.line1 = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.line2 = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.line3 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreetAddressDTO {
    return {
      line1: isSet(object.line1)
        ? globalThis.String(object.line1)
        : isSet(object.line_1)
        ? globalThis.String(object.line_1)
        : "",
      line2: isSet(object.line2)
        ? globalThis.String(object.line2)
        : isSet(object.line_2)
        ? globalThis.String(object.line_2)
        : "",
      line3: isSet(object.line3)
        ? globalThis.String(object.line3)
        : isSet(object.line_3)
        ? globalThis.String(object.line_3)
        : "",
    };
  },

  toJSON(message: StreetAddressDTO): unknown {
    const obj: any = {};
    if (message.line1 !== "") {
      obj.line1 = message.line1;
    }
    if (message.line2 !== "") {
      obj.line2 = message.line2;
    }
    if (message.line3 !== "") {
      obj.line3 = message.line3;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreetAddressDTO>, I>>(base?: I): StreetAddressDTO {
    return StreetAddressDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreetAddressDTO>, I>>(object: I): StreetAddressDTO {
    const message = createBaseStreetAddressDTO();
    message.line1 = object.line1 ?? "";
    message.line2 = object.line2 ?? "";
    message.line3 = object.line3 ?? "";
    return message;
  },
};

function createBaseEmailAddressDTO(): EmailAddressDTO {
  return { value: "", labels: [] };
}

export const EmailAddressDTO: MessageFns<EmailAddressDTO> = {
  encode(message: EmailAddressDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    for (const v of message.labels) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailAddressDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailAddressDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.labels.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmailAddressDTO {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: EmailAddressDTO): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.labels?.length) {
      obj.labels = message.labels;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmailAddressDTO>, I>>(base?: I): EmailAddressDTO {
    return EmailAddressDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmailAddressDTO>, I>>(object: I): EmailAddressDTO {
    const message = createBaseEmailAddressDTO();
    message.value = object.value ?? "";
    message.labels = object.labels?.map((e) => e) || [];
    return message;
  },
};

function createBasePhoneNumberDTO(): PhoneNumberDTO {
  return { value: "", labels: [] };
}

export const PhoneNumberDTO: MessageFns<PhoneNumberDTO> = {
  encode(message: PhoneNumberDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    for (const v of message.labels) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhoneNumberDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhoneNumberDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.labels.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhoneNumberDTO {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: PhoneNumberDTO): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.labels?.length) {
      obj.labels = message.labels;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PhoneNumberDTO>, I>>(base?: I): PhoneNumberDTO {
    return PhoneNumberDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PhoneNumberDTO>, I>>(object: I): PhoneNumberDTO {
    const message = createBasePhoneNumberDTO();
    message.value = object.value ?? "";
    message.labels = object.labels?.map((e) => e) || [];
    return message;
  },
};

function createBasePersonalDTO(): PersonalDTO {
  return {
    title: "",
    firstName: "",
    preferredName: "",
    middleName: "",
    lastName: "",
    generationalSuffix: "",
    professionalCredentials: [],
    dateOfBirth: "",
    biologicalSex: "",
  };
}

export const PersonalDTO: MessageFns<PersonalDTO> = {
  encode(message: PersonalDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.firstName !== "") {
      writer.uint32(18).string(message.firstName);
    }
    if (message.preferredName !== "") {
      writer.uint32(26).string(message.preferredName);
    }
    if (message.middleName !== "") {
      writer.uint32(34).string(message.middleName);
    }
    if (message.lastName !== "") {
      writer.uint32(42).string(message.lastName);
    }
    if (message.generationalSuffix !== "") {
      writer.uint32(50).string(message.generationalSuffix);
    }
    for (const v of message.professionalCredentials) {
      writer.uint32(58).string(v!);
    }
    if (message.dateOfBirth !== "") {
      writer.uint32(66).string(message.dateOfBirth);
    }
    if (message.biologicalSex !== "") {
      writer.uint32(74).string(message.biologicalSex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonalDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.preferredName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.middleName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.generationalSuffix = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.professionalCredentials.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dateOfBirth = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.biologicalSex = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalDTO {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      firstName: isSet(object.firstName)
        ? globalThis.String(object.firstName)
        : isSet(object.first_name)
        ? globalThis.String(object.first_name)
        : "",
      preferredName: isSet(object.preferredName)
        ? globalThis.String(object.preferredName)
        : isSet(object.preferred_name)
        ? globalThis.String(object.preferred_name)
        : "",
      middleName: isSet(object.middleName)
        ? globalThis.String(object.middleName)
        : isSet(object.middle_name)
        ? globalThis.String(object.middle_name)
        : "",
      lastName: isSet(object.lastName)
        ? globalThis.String(object.lastName)
        : isSet(object.last_name)
        ? globalThis.String(object.last_name)
        : "",
      generationalSuffix: isSet(object.generationalSuffix)
        ? globalThis.String(object.generationalSuffix)
        : isSet(object.generational_suffix)
        ? globalThis.String(object.generational_suffix)
        : "",
      professionalCredentials: globalThis.Array.isArray(object?.professionalCredentials)
        ? object.professionalCredentials.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.professional_credentials)
        ? object.professional_credentials.map((e: any) => globalThis.String(e))
        : [],
      dateOfBirth: isSet(object.dateOfBirth)
        ? globalThis.String(object.dateOfBirth)
        : isSet(object.date_of_birth)
        ? globalThis.String(object.date_of_birth)
        : "",
      biologicalSex: isSet(object.biologicalSex)
        ? globalThis.String(object.biologicalSex)
        : isSet(object.biological_sex)
        ? globalThis.String(object.biological_sex)
        : "",
    };
  },

  toJSON(message: PersonalDTO): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.preferredName !== "") {
      obj.preferredName = message.preferredName;
    }
    if (message.middleName !== "") {
      obj.middleName = message.middleName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.generationalSuffix !== "") {
      obj.generationalSuffix = message.generationalSuffix;
    }
    if (message.professionalCredentials?.length) {
      obj.professionalCredentials = message.professionalCredentials;
    }
    if (message.dateOfBirth !== "") {
      obj.dateOfBirth = message.dateOfBirth;
    }
    if (message.biologicalSex !== "") {
      obj.biologicalSex = message.biologicalSex;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PersonalDTO>, I>>(base?: I): PersonalDTO {
    return PersonalDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PersonalDTO>, I>>(object: I): PersonalDTO {
    const message = createBasePersonalDTO();
    message.title = object.title ?? "";
    message.firstName = object.firstName ?? "";
    message.preferredName = object.preferredName ?? "";
    message.middleName = object.middleName ?? "";
    message.lastName = object.lastName ?? "";
    message.generationalSuffix = object.generationalSuffix ?? "";
    message.professionalCredentials = object.professionalCredentials?.map((e) => e) || [];
    message.dateOfBirth = object.dateOfBirth ?? "";
    message.biologicalSex = object.biologicalSex ?? "";
    return message;
  },
};

function createBaseProfessionalDTO(): ProfessionalDTO {
  return { companyName: "", jobTitle: "", department: "", companyWebsite: "" };
}

export const ProfessionalDTO: MessageFns<ProfessionalDTO> = {
  encode(message: ProfessionalDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.companyName !== "") {
      writer.uint32(10).string(message.companyName);
    }
    if (message.jobTitle !== "") {
      writer.uint32(18).string(message.jobTitle);
    }
    if (message.department !== "") {
      writer.uint32(26).string(message.department);
    }
    if (message.companyWebsite !== "") {
      writer.uint32(34).string(message.companyWebsite);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProfessionalDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfessionalDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.companyName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jobTitle = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.department = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.companyWebsite = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProfessionalDTO {
    return {
      companyName: isSet(object.companyName)
        ? globalThis.String(object.companyName)
        : isSet(object.company_name)
        ? globalThis.String(object.company_name)
        : "",
      jobTitle: isSet(object.jobTitle)
        ? globalThis.String(object.jobTitle)
        : isSet(object.job_title)
        ? globalThis.String(object.job_title)
        : "",
      department: isSet(object.department) ? globalThis.String(object.department) : "",
      companyWebsite: isSet(object.companyWebsite)
        ? globalThis.String(object.companyWebsite)
        : isSet(object.company_website)
        ? globalThis.String(object.company_website)
        : "",
    };
  },

  toJSON(message: ProfessionalDTO): unknown {
    const obj: any = {};
    if (message.companyName !== "") {
      obj.companyName = message.companyName;
    }
    if (message.jobTitle !== "") {
      obj.jobTitle = message.jobTitle;
    }
    if (message.department !== "") {
      obj.department = message.department;
    }
    if (message.companyWebsite !== "") {
      obj.companyWebsite = message.companyWebsite;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProfessionalDTO>, I>>(base?: I): ProfessionalDTO {
    return ProfessionalDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProfessionalDTO>, I>>(object: I): ProfessionalDTO {
    const message = createBaseProfessionalDTO();
    message.companyName = object.companyName ?? "";
    message.jobTitle = object.jobTitle ?? "";
    message.department = object.department ?? "";
    message.companyWebsite = object.companyWebsite ?? "";
    return message;
  },
};

function createBaseContactMethodsDTO(): ContactMethodsDTO {
  return { emails: [], phoneNumbers: [] };
}

export const ContactMethodsDTO: MessageFns<ContactMethodsDTO> = {
  encode(message: ContactMethodsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.emails) {
      EmailAddressDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.phoneNumbers) {
      PhoneNumberDTO.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContactMethodsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContactMethodsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emails.push(EmailAddressDTO.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.phoneNumbers.push(PhoneNumberDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContactMethodsDTO {
    return {
      emails: globalThis.Array.isArray(object?.emails)
        ? object.emails.map((e: any) => EmailAddressDTO.fromJSON(e))
        : [],
      phoneNumbers: globalThis.Array.isArray(object?.phoneNumbers)
        ? object.phoneNumbers.map((e: any) => PhoneNumberDTO.fromJSON(e))
        : globalThis.Array.isArray(object?.phone_numbers)
        ? object.phone_numbers.map((e: any) => PhoneNumberDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ContactMethodsDTO): unknown {
    const obj: any = {};
    if (message.emails?.length) {
      obj.emails = message.emails.map((e) => EmailAddressDTO.toJSON(e));
    }
    if (message.phoneNumbers?.length) {
      obj.phoneNumbers = message.phoneNumbers.map((e) => PhoneNumberDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContactMethodsDTO>, I>>(base?: I): ContactMethodsDTO {
    return ContactMethodsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContactMethodsDTO>, I>>(object: I): ContactMethodsDTO {
    const message = createBaseContactMethodsDTO();
    message.emails = object.emails?.map((e) => EmailAddressDTO.fromPartial(e)) || [];
    message.phoneNumbers = object.phoneNumbers?.map((e) => PhoneNumberDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLocationDTO(): LocationDTO {
  return {
    hashId: "",
    coordinates: undefined,
    address: undefined,
    city: "",
    postalCode: "",
    subdivisionIso31662Code: "",
    countryIso31661Alpha2Code: "",
  };
}

export const LocationDTO: MessageFns<LocationDTO> = {
  encode(message: LocationDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hashId !== "") {
      writer.uint32(10).string(message.hashId);
    }
    if (message.coordinates !== undefined) {
      CoordinatesDTO.encode(message.coordinates, writer.uint32(18).fork()).join();
    }
    if (message.address !== undefined) {
      StreetAddressDTO.encode(message.address, writer.uint32(26).fork()).join();
    }
    if (message.city !== "") {
      writer.uint32(34).string(message.city);
    }
    if (message.postalCode !== "") {
      writer.uint32(42).string(message.postalCode);
    }
    if (message.subdivisionIso31662Code !== "") {
      writer.uint32(50).string(message.subdivisionIso31662Code);
    }
    if (message.countryIso31661Alpha2Code !== "") {
      writer.uint32(58).string(message.countryIso31661Alpha2Code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hashId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.coordinates = CoordinatesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = StreetAddressDTO.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.postalCode = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.subdivisionIso31662Code = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.countryIso31661Alpha2Code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationDTO {
    return {
      hashId: isSet(object.hashId)
        ? globalThis.String(object.hashId)
        : isSet(object.hash_id)
        ? globalThis.String(object.hash_id)
        : "",
      coordinates: isSet(object.coordinates) ? CoordinatesDTO.fromJSON(object.coordinates) : undefined,
      address: isSet(object.address) ? StreetAddressDTO.fromJSON(object.address) : undefined,
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      postalCode: isSet(object.postalCode)
        ? globalThis.String(object.postalCode)
        : isSet(object.postal_code)
        ? globalThis.String(object.postal_code)
        : "",
      subdivisionIso31662Code: isSet(object.subdivisionIso31662Code)
        ? globalThis.String(object.subdivisionIso31662Code)
        : isSet(object.subdivision_iso_3166_2_code)
        ? globalThis.String(object.subdivision_iso_3166_2_code)
        : "",
      countryIso31661Alpha2Code: isSet(object.countryIso31661Alpha2Code)
        ? globalThis.String(object.countryIso31661Alpha2Code)
        : isSet(object.country_iso_3166_1_alpha_2_code)
        ? globalThis.String(object.country_iso_3166_1_alpha_2_code)
        : "",
    };
  },

  toJSON(message: LocationDTO): unknown {
    const obj: any = {};
    if (message.hashId !== "") {
      obj.hashId = message.hashId;
    }
    if (message.coordinates !== undefined) {
      obj.coordinates = CoordinatesDTO.toJSON(message.coordinates);
    }
    if (message.address !== undefined) {
      obj.address = StreetAddressDTO.toJSON(message.address);
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.postalCode !== "") {
      obj.postalCode = message.postalCode;
    }
    if (message.subdivisionIso31662Code !== "") {
      obj.subdivisionIso31662Code = message.subdivisionIso31662Code;
    }
    if (message.countryIso31661Alpha2Code !== "") {
      obj.countryIso31661Alpha2Code = message.countryIso31661Alpha2Code;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocationDTO>, I>>(base?: I): LocationDTO {
    return LocationDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocationDTO>, I>>(object: I): LocationDTO {
    const message = createBaseLocationDTO();
    message.hashId = object.hashId ?? "";
    message.coordinates = (object.coordinates !== undefined && object.coordinates !== null)
      ? CoordinatesDTO.fromPartial(object.coordinates)
      : undefined;
    message.address = (object.address !== undefined && object.address !== null)
      ? StreetAddressDTO.fromPartial(object.address)
      : undefined;
    message.city = object.city ?? "";
    message.postalCode = object.postalCode ?? "";
    message.subdivisionIso31662Code = object.subdivisionIso31662Code ?? "";
    message.countryIso31661Alpha2Code = object.countryIso31661Alpha2Code ?? "";
    return message;
  },
};

function createBaseWhoIsDTO(): WhoIsDTO {
  return {
    hashId: "",
    ipAddress: "",
    year: 0,
    month: 0,
    fingerprint: "",
    asn: 0,
    asName: "",
    asDomain: "",
    asType: "",
    carrierName: "",
    mcc: "",
    mnc: "",
    asChanged: "",
    geoChanged: "",
    isAnonymous: false,
    isAnycast: false,
    isHosting: false,
    isMobile: false,
    isSatellite: false,
    isProxy: false,
    isRelay: false,
    isTor: false,
    isVpn: false,
    privacyName: "",
    location: undefined,
  };
}

export const WhoIsDTO: MessageFns<WhoIsDTO> = {
  encode(message: WhoIsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hashId !== "") {
      writer.uint32(10).string(message.hashId);
    }
    if (message.ipAddress !== "") {
      writer.uint32(18).string(message.ipAddress);
    }
    if (message.year !== 0) {
      writer.uint32(24).int32(message.year);
    }
    if (message.month !== 0) {
      writer.uint32(32).int32(message.month);
    }
    if (message.fingerprint !== "") {
      writer.uint32(42).string(message.fingerprint);
    }
    if (message.asn !== 0) {
      writer.uint32(48).int32(message.asn);
    }
    if (message.asName !== "") {
      writer.uint32(58).string(message.asName);
    }
    if (message.asDomain !== "") {
      writer.uint32(66).string(message.asDomain);
    }
    if (message.asType !== "") {
      writer.uint32(74).string(message.asType);
    }
    if (message.carrierName !== "") {
      writer.uint32(82).string(message.carrierName);
    }
    if (message.mcc !== "") {
      writer.uint32(90).string(message.mcc);
    }
    if (message.mnc !== "") {
      writer.uint32(98).string(message.mnc);
    }
    if (message.asChanged !== "") {
      writer.uint32(106).string(message.asChanged);
    }
    if (message.geoChanged !== "") {
      writer.uint32(114).string(message.geoChanged);
    }
    if (message.isAnonymous !== false) {
      writer.uint32(120).bool(message.isAnonymous);
    }
    if (message.isAnycast !== false) {
      writer.uint32(128).bool(message.isAnycast);
    }
    if (message.isHosting !== false) {
      writer.uint32(136).bool(message.isHosting);
    }
    if (message.isMobile !== false) {
      writer.uint32(144).bool(message.isMobile);
    }
    if (message.isSatellite !== false) {
      writer.uint32(152).bool(message.isSatellite);
    }
    if (message.isProxy !== false) {
      writer.uint32(160).bool(message.isProxy);
    }
    if (message.isRelay !== false) {
      writer.uint32(168).bool(message.isRelay);
    }
    if (message.isTor !== false) {
      writer.uint32(176).bool(message.isTor);
    }
    if (message.isVpn !== false) {
      writer.uint32(184).bool(message.isVpn);
    }
    if (message.privacyName !== "") {
      writer.uint32(194).string(message.privacyName);
    }
    if (message.location !== undefined) {
      LocationDTO.encode(message.location, writer.uint32(202).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WhoIsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhoIsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hashId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.month = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fingerprint = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.asn = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.asName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.asDomain = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.asType = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.carrierName = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.mcc = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.mnc = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.asChanged = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.geoChanged = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.isAnonymous = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.isAnycast = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.isHosting = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.isMobile = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.isSatellite = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.isProxy = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.isRelay = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.isTor = reader.bool();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.isVpn = reader.bool();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.privacyName = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.location = LocationDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhoIsDTO {
    return {
      hashId: isSet(object.hashId)
        ? globalThis.String(object.hashId)
        : isSet(object.hash_id)
        ? globalThis.String(object.hash_id)
        : "",
      ipAddress: isSet(object.ipAddress)
        ? globalThis.String(object.ipAddress)
        : isSet(object.ip_address)
        ? globalThis.String(object.ip_address)
        : "",
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
      month: isSet(object.month) ? globalThis.Number(object.month) : 0,
      fingerprint: isSet(object.fingerprint) ? globalThis.String(object.fingerprint) : "",
      asn: isSet(object.asn) ? globalThis.Number(object.asn) : 0,
      asName: isSet(object.asName)
        ? globalThis.String(object.asName)
        : isSet(object.as_name)
        ? globalThis.String(object.as_name)
        : "",
      asDomain: isSet(object.asDomain)
        ? globalThis.String(object.asDomain)
        : isSet(object.as_domain)
        ? globalThis.String(object.as_domain)
        : "",
      asType: isSet(object.asType)
        ? globalThis.String(object.asType)
        : isSet(object.as_type)
        ? globalThis.String(object.as_type)
        : "",
      carrierName: isSet(object.carrierName)
        ? globalThis.String(object.carrierName)
        : isSet(object.carrier_name)
        ? globalThis.String(object.carrier_name)
        : "",
      mcc: isSet(object.mcc) ? globalThis.String(object.mcc) : "",
      mnc: isSet(object.mnc) ? globalThis.String(object.mnc) : "",
      asChanged: isSet(object.asChanged)
        ? globalThis.String(object.asChanged)
        : isSet(object.as_changed)
        ? globalThis.String(object.as_changed)
        : "",
      geoChanged: isSet(object.geoChanged)
        ? globalThis.String(object.geoChanged)
        : isSet(object.geo_changed)
        ? globalThis.String(object.geo_changed)
        : "",
      isAnonymous: isSet(object.isAnonymous)
        ? globalThis.Boolean(object.isAnonymous)
        : isSet(object.is_anonymous)
        ? globalThis.Boolean(object.is_anonymous)
        : false,
      isAnycast: isSet(object.isAnycast)
        ? globalThis.Boolean(object.isAnycast)
        : isSet(object.is_anycast)
        ? globalThis.Boolean(object.is_anycast)
        : false,
      isHosting: isSet(object.isHosting)
        ? globalThis.Boolean(object.isHosting)
        : isSet(object.is_hosting)
        ? globalThis.Boolean(object.is_hosting)
        : false,
      isMobile: isSet(object.isMobile)
        ? globalThis.Boolean(object.isMobile)
        : isSet(object.is_mobile)
        ? globalThis.Boolean(object.is_mobile)
        : false,
      isSatellite: isSet(object.isSatellite)
        ? globalThis.Boolean(object.isSatellite)
        : isSet(object.is_satellite)
        ? globalThis.Boolean(object.is_satellite)
        : false,
      isProxy: isSet(object.isProxy)
        ? globalThis.Boolean(object.isProxy)
        : isSet(object.is_proxy)
        ? globalThis.Boolean(object.is_proxy)
        : false,
      isRelay: isSet(object.isRelay)
        ? globalThis.Boolean(object.isRelay)
        : isSet(object.is_relay)
        ? globalThis.Boolean(object.is_relay)
        : false,
      isTor: isSet(object.isTor)
        ? globalThis.Boolean(object.isTor)
        : isSet(object.is_tor)
        ? globalThis.Boolean(object.is_tor)
        : false,
      isVpn: isSet(object.isVpn)
        ? globalThis.Boolean(object.isVpn)
        : isSet(object.is_vpn)
        ? globalThis.Boolean(object.is_vpn)
        : false,
      privacyName: isSet(object.privacyName)
        ? globalThis.String(object.privacyName)
        : isSet(object.privacy_name)
        ? globalThis.String(object.privacy_name)
        : "",
      location: isSet(object.location) ? LocationDTO.fromJSON(object.location) : undefined,
    };
  },

  toJSON(message: WhoIsDTO): unknown {
    const obj: any = {};
    if (message.hashId !== "") {
      obj.hashId = message.hashId;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.month !== 0) {
      obj.month = Math.round(message.month);
    }
    if (message.fingerprint !== "") {
      obj.fingerprint = message.fingerprint;
    }
    if (message.asn !== 0) {
      obj.asn = Math.round(message.asn);
    }
    if (message.asName !== "") {
      obj.asName = message.asName;
    }
    if (message.asDomain !== "") {
      obj.asDomain = message.asDomain;
    }
    if (message.asType !== "") {
      obj.asType = message.asType;
    }
    if (message.carrierName !== "") {
      obj.carrierName = message.carrierName;
    }
    if (message.mcc !== "") {
      obj.mcc = message.mcc;
    }
    if (message.mnc !== "") {
      obj.mnc = message.mnc;
    }
    if (message.asChanged !== "") {
      obj.asChanged = message.asChanged;
    }
    if (message.geoChanged !== "") {
      obj.geoChanged = message.geoChanged;
    }
    if (message.isAnonymous !== false) {
      obj.isAnonymous = message.isAnonymous;
    }
    if (message.isAnycast !== false) {
      obj.isAnycast = message.isAnycast;
    }
    if (message.isHosting !== false) {
      obj.isHosting = message.isHosting;
    }
    if (message.isMobile !== false) {
      obj.isMobile = message.isMobile;
    }
    if (message.isSatellite !== false) {
      obj.isSatellite = message.isSatellite;
    }
    if (message.isProxy !== false) {
      obj.isProxy = message.isProxy;
    }
    if (message.isRelay !== false) {
      obj.isRelay = message.isRelay;
    }
    if (message.isTor !== false) {
      obj.isTor = message.isTor;
    }
    if (message.isVpn !== false) {
      obj.isVpn = message.isVpn;
    }
    if (message.privacyName !== "") {
      obj.privacyName = message.privacyName;
    }
    if (message.location !== undefined) {
      obj.location = LocationDTO.toJSON(message.location);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhoIsDTO>, I>>(base?: I): WhoIsDTO {
    return WhoIsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhoIsDTO>, I>>(object: I): WhoIsDTO {
    const message = createBaseWhoIsDTO();
    message.hashId = object.hashId ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.year = object.year ?? 0;
    message.month = object.month ?? 0;
    message.fingerprint = object.fingerprint ?? "";
    message.asn = object.asn ?? 0;
    message.asName = object.asName ?? "";
    message.asDomain = object.asDomain ?? "";
    message.asType = object.asType ?? "";
    message.carrierName = object.carrierName ?? "";
    message.mcc = object.mcc ?? "";
    message.mnc = object.mnc ?? "";
    message.asChanged = object.asChanged ?? "";
    message.geoChanged = object.geoChanged ?? "";
    message.isAnonymous = object.isAnonymous ?? false;
    message.isAnycast = object.isAnycast ?? false;
    message.isHosting = object.isHosting ?? false;
    message.isMobile = object.isMobile ?? false;
    message.isSatellite = object.isSatellite ?? false;
    message.isProxy = object.isProxy ?? false;
    message.isRelay = object.isRelay ?? false;
    message.isTor = object.isTor ?? false;
    message.isVpn = object.isVpn ?? false;
    message.privacyName = object.privacyName ?? "";
    message.location = (object.location !== undefined && object.location !== null)
      ? LocationDTO.fromPartial(object.location)
      : undefined;
    return message;
  },
};

function createBaseContactDTO(): ContactDTO {
  return {
    id: "",
    createdAt: undefined,
    contextKey: "",
    relatedEntityId: "",
    contactMethods: undefined,
    personalDetails: undefined,
    professionalDetails: undefined,
    location: undefined,
  };
}

export const ContactDTO: MessageFns<ContactDTO> = {
  encode(message: ContactDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).join();
    }
    if (message.contextKey !== "") {
      writer.uint32(26).string(message.contextKey);
    }
    if (message.relatedEntityId !== "") {
      writer.uint32(34).string(message.relatedEntityId);
    }
    if (message.contactMethods !== undefined) {
      ContactMethodsDTO.encode(message.contactMethods, writer.uint32(42).fork()).join();
    }
    if (message.personalDetails !== undefined) {
      PersonalDTO.encode(message.personalDetails, writer.uint32(50).fork()).join();
    }
    if (message.professionalDetails !== undefined) {
      ProfessionalDTO.encode(message.professionalDetails, writer.uint32(58).fork()).join();
    }
    if (message.location !== undefined) {
      LocationDTO.encode(message.location, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContactDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContactDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contextKey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.relatedEntityId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contactMethods = ContactMethodsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.personalDetails = PersonalDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.professionalDetails = ProfessionalDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.location = LocationDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContactDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet(object.createdAt)
        ? fromJsonTimestamp(object.createdAt)
        : isSet(object.created_at)
        ? fromJsonTimestamp(object.created_at)
        : undefined,
      contextKey: isSet(object.contextKey)
        ? globalThis.String(object.contextKey)
        : isSet(object.context_key)
        ? globalThis.String(object.context_key)
        : "",
      relatedEntityId: isSet(object.relatedEntityId)
        ? globalThis.String(object.relatedEntityId)
        : isSet(object.related_entity_id)
        ? globalThis.String(object.related_entity_id)
        : "",
      contactMethods: isSet(object.contactMethods)
        ? ContactMethodsDTO.fromJSON(object.contactMethods)
        : isSet(object.contact_methods)
        ? ContactMethodsDTO.fromJSON(object.contact_methods)
        : undefined,
      personalDetails: isSet(object.personalDetails)
        ? PersonalDTO.fromJSON(object.personalDetails)
        : isSet(object.personal_details)
        ? PersonalDTO.fromJSON(object.personal_details)
        : undefined,
      professionalDetails: isSet(object.professionalDetails)
        ? ProfessionalDTO.fromJSON(object.professionalDetails)
        : isSet(object.professional_details)
        ? ProfessionalDTO.fromJSON(object.professional_details)
        : undefined,
      location: isSet(object.location) ? LocationDTO.fromJSON(object.location) : undefined,
    };
  },

  toJSON(message: ContactDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.contextKey !== "") {
      obj.contextKey = message.contextKey;
    }
    if (message.relatedEntityId !== "") {
      obj.relatedEntityId = message.relatedEntityId;
    }
    if (message.contactMethods !== undefined) {
      obj.contactMethods = ContactMethodsDTO.toJSON(message.contactMethods);
    }
    if (message.personalDetails !== undefined) {
      obj.personalDetails = PersonalDTO.toJSON(message.personalDetails);
    }
    if (message.professionalDetails !== undefined) {
      obj.professionalDetails = ProfessionalDTO.toJSON(message.professionalDetails);
    }
    if (message.location !== undefined) {
      obj.location = LocationDTO.toJSON(message.location);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContactDTO>, I>>(base?: I): ContactDTO {
    return ContactDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContactDTO>, I>>(object: I): ContactDTO {
    const message = createBaseContactDTO();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.contextKey = object.contextKey ?? "";
    message.relatedEntityId = object.relatedEntityId ?? "";
    message.contactMethods = (object.contactMethods !== undefined && object.contactMethods !== null)
      ? ContactMethodsDTO.fromPartial(object.contactMethods)
      : undefined;
    message.personalDetails = (object.personalDetails !== undefined && object.personalDetails !== null)
      ? PersonalDTO.fromPartial(object.personalDetails)
      : undefined;
    message.professionalDetails = (object.professionalDetails !== undefined && object.professionalDetails !== null)
      ? ProfessionalDTO.fromPartial(object.professionalDetails)
      : undefined;
    message.location = (object.location !== undefined && object.location !== null)
      ? LocationDTO.fromPartial(object.location)
      : undefined;
    return message;
  },
};

export type GeoServiceService = typeof GeoServiceService;
export const GeoServiceService = {
  getReferenceData: {
    path: "/d2.geo.v1.GeoService/GetReferenceData",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetReferenceDataRequest): Buffer =>
      Buffer.from(GetReferenceDataRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetReferenceDataRequest => GetReferenceDataRequest.decode(value),
    responseSerialize: (value: GetReferenceDataResponse): Buffer =>
      Buffer.from(GetReferenceDataResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetReferenceDataResponse => GetReferenceDataResponse.decode(value),
  },
  requestReferenceDataUpdate: {
    path: "/d2.geo.v1.GeoService/RequestReferenceDataUpdate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RequestReferenceDataUpdateRequest): Buffer =>
      Buffer.from(RequestReferenceDataUpdateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RequestReferenceDataUpdateRequest =>
      RequestReferenceDataUpdateRequest.decode(value),
    responseSerialize: (value: RequestReferenceDataUpdateResponse): Buffer =>
      Buffer.from(RequestReferenceDataUpdateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RequestReferenceDataUpdateResponse =>
      RequestReferenceDataUpdateResponse.decode(value),
  },
  findWhoIs: {
    path: "/d2.geo.v1.GeoService/FindWhoIs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FindWhoIsRequest): Buffer => Buffer.from(FindWhoIsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): FindWhoIsRequest => FindWhoIsRequest.decode(value),
    responseSerialize: (value: FindWhoIsResponse): Buffer => Buffer.from(FindWhoIsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): FindWhoIsResponse => FindWhoIsResponse.decode(value),
  },
  getContacts: {
    path: "/d2.geo.v1.GeoService/GetContacts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetContactsRequest): Buffer => Buffer.from(GetContactsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetContactsRequest => GetContactsRequest.decode(value),
    responseSerialize: (value: GetContactsResponse): Buffer => Buffer.from(GetContactsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetContactsResponse => GetContactsResponse.decode(value),
  },
  getContactsByExtKeys: {
    path: "/d2.geo.v1.GeoService/GetContactsByExtKeys",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetContactsByExtKeysRequest): Buffer =>
      Buffer.from(GetContactsByExtKeysRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetContactsByExtKeysRequest => GetContactsByExtKeysRequest.decode(value),
    responseSerialize: (value: GetContactsByExtKeysResponse): Buffer =>
      Buffer.from(GetContactsByExtKeysResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetContactsByExtKeysResponse => GetContactsByExtKeysResponse.decode(value),
  },
  createContacts: {
    path: "/d2.geo.v1.GeoService/CreateContacts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateContactsRequest): Buffer =>
      Buffer.from(CreateContactsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateContactsRequest => CreateContactsRequest.decode(value),
    responseSerialize: (value: CreateContactsResponse): Buffer =>
      Buffer.from(CreateContactsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateContactsResponse => CreateContactsResponse.decode(value),
  },
  deleteContacts: {
    path: "/d2.geo.v1.GeoService/DeleteContacts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteContactsRequest): Buffer =>
      Buffer.from(DeleteContactsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteContactsRequest => DeleteContactsRequest.decode(value),
    responseSerialize: (value: DeleteContactsResponse): Buffer =>
      Buffer.from(DeleteContactsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteContactsResponse => DeleteContactsResponse.decode(value),
  },
} as const;

export interface GeoServiceServer extends UntypedServiceImplementation {
  getReferenceData: handleUnaryCall<GetReferenceDataRequest, GetReferenceDataResponse>;
  requestReferenceDataUpdate: handleUnaryCall<RequestReferenceDataUpdateRequest, RequestReferenceDataUpdateResponse>;
  findWhoIs: handleUnaryCall<FindWhoIsRequest, FindWhoIsResponse>;
  getContacts: handleUnaryCall<GetContactsRequest, GetContactsResponse>;
  getContactsByExtKeys: handleUnaryCall<GetContactsByExtKeysRequest, GetContactsByExtKeysResponse>;
  createContacts: handleUnaryCall<CreateContactsRequest, CreateContactsResponse>;
  deleteContacts: handleUnaryCall<DeleteContactsRequest, DeleteContactsResponse>;
}

export interface GeoServiceClient extends Client {
  getReferenceData(
    request: GetReferenceDataRequest,
    callback: (error: ServiceError | null, response: GetReferenceDataResponse) => void,
  ): ClientUnaryCall;
  getReferenceData(
    request: GetReferenceDataRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetReferenceDataResponse) => void,
  ): ClientUnaryCall;
  getReferenceData(
    request: GetReferenceDataRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetReferenceDataResponse) => void,
  ): ClientUnaryCall;
  requestReferenceDataUpdate(
    request: RequestReferenceDataUpdateRequest,
    callback: (error: ServiceError | null, response: RequestReferenceDataUpdateResponse) => void,
  ): ClientUnaryCall;
  requestReferenceDataUpdate(
    request: RequestReferenceDataUpdateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RequestReferenceDataUpdateResponse) => void,
  ): ClientUnaryCall;
  requestReferenceDataUpdate(
    request: RequestReferenceDataUpdateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RequestReferenceDataUpdateResponse) => void,
  ): ClientUnaryCall;
  findWhoIs(
    request: FindWhoIsRequest,
    callback: (error: ServiceError | null, response: FindWhoIsResponse) => void,
  ): ClientUnaryCall;
  findWhoIs(
    request: FindWhoIsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: FindWhoIsResponse) => void,
  ): ClientUnaryCall;
  findWhoIs(
    request: FindWhoIsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: FindWhoIsResponse) => void,
  ): ClientUnaryCall;
  getContacts(
    request: GetContactsRequest,
    callback: (error: ServiceError | null, response: GetContactsResponse) => void,
  ): ClientUnaryCall;
  getContacts(
    request: GetContactsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetContactsResponse) => void,
  ): ClientUnaryCall;
  getContacts(
    request: GetContactsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetContactsResponse) => void,
  ): ClientUnaryCall;
  getContactsByExtKeys(
    request: GetContactsByExtKeysRequest,
    callback: (error: ServiceError | null, response: GetContactsByExtKeysResponse) => void,
  ): ClientUnaryCall;
  getContactsByExtKeys(
    request: GetContactsByExtKeysRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetContactsByExtKeysResponse) => void,
  ): ClientUnaryCall;
  getContactsByExtKeys(
    request: GetContactsByExtKeysRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetContactsByExtKeysResponse) => void,
  ): ClientUnaryCall;
  createContacts(
    request: CreateContactsRequest,
    callback: (error: ServiceError | null, response: CreateContactsResponse) => void,
  ): ClientUnaryCall;
  createContacts(
    request: CreateContactsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateContactsResponse) => void,
  ): ClientUnaryCall;
  createContacts(
    request: CreateContactsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateContactsResponse) => void,
  ): ClientUnaryCall;
  deleteContacts(
    request: DeleteContactsRequest,
    callback: (error: ServiceError | null, response: DeleteContactsResponse) => void,
  ): ClientUnaryCall;
  deleteContacts(
    request: DeleteContactsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteContactsResponse) => void,
  ): ClientUnaryCall;
  deleteContacts(
    request: DeleteContactsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteContactsResponse) => void,
  ): ClientUnaryCall;
}

export const GeoServiceClient = makeGenericClientConstructor(GeoServiceService, "d2.geo.v1.GeoService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): GeoServiceClient;
  service: typeof GeoServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
