### Module 25: Cross-Cutting Sweep

**Files reviewed**: 42 files

- E2E tests: 12 files (3 test files, 6 helpers, vitest config, setup, global-setup, package.json)
- Observability: 13 files (6 config files, 7 dashboard JSONs referenced)
- Root tooling: 9 files (eslint, prettier, vitest workspace, vitest shared, tsconfig base, pnpm workspace, package.json, .npmrc, D2.sln)
- Cross-service comparison: 8 files (auth/comms app/infra registration, auth/comms composition roots, Geo Program.cs, auth/comms api index)

---

#### E2E Tests

The E2E test suite at `backends/node/services/e2e/` is well-structured and validates the critical Auth -> Comms -> Geo cross-service pipeline across 5 tests in 3 test files. Infrastructure is managed via Testcontainers (PostgreSQL, RabbitMQ, Redis) + a .NET Geo.API child process. The helpers are clean and follow good patterns (in-process service starts, stub email provider, async polling).

**Findings**:
| #  | Severity | Category        | File                                                      | Description                                                                                                                                                                                                                                                                                                    |
|----|----------|-----------------|-----------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1  | Medium   | Maintainability | `e2e/src/helpers/containers.ts`, `auth-service.ts`, `comms-service.ts` | `withTimeout` utility function is duplicated identically across 3 helper files (containers.ts:48, auth-service.ts:73, comms-service.ts:143). Should be extracted to a shared utility, e.g., `helpers/with-timeout.ts`, and imported by all three.                                                               |
| 2  | Medium   | Maintainability | `e2e/src/e2e/*.test.ts`                                   | All 3 test files repeat identical `beforeAll`/`afterAll` infrastructure setup (startContainers, startGeoService, startAuthService, startCommsService, then reverse teardown). This ~30-line block could be extracted to a shared test fixture function, reducing duplication and ensuring consistent ordering.    |
| 3  | Low      | Consistency     | `e2e/src/e2e/verification-email.test.ts`                  | The `GEO_API_KEY` constant (`"e2e-test-key"`) is duplicated as a top-level const in all 3 test files. Should be a single export from a shared constants file or from the helpers module.                                                                                                                       |
| 4  | Low      | Maintainability | `e2e/src/helpers/comms-service.ts`                        | Line 160: `(geoClient as unknown as { close(): void }).close()` uses a double cast to call `close()` on the gRPC client. The `createGeoServiceClient` return type should expose a `close` method, or this helper should store the underlying gRPC client handle directly.                                      |
| 5  | Low      | Test Gap        | `e2e/src/e2e/`                                            | No E2E test for negative/failure scenarios: e.g., what happens when Geo service is down during sign-up (expected: sign-up fails entirely per architecture docs), or when RabbitMQ is unavailable (expected: email not delivered but sign-up succeeds). Negative path coverage would increase confidence.         |
| 6  | Info     | Elegance        | `e2e/src/helpers/wait.ts`                                 | `waitForRow` and `waitForRows` accept a generic `pg.Pool` import but the `pg` type import at line 1 is unused in the function signatures (it uses the imported `Pool` type). Minor: the `pg` default import is used correctly, just noting the type import pattern.                                            |
| 7  | Info     | Maintainability | `e2e/src/e2e/invitation-email.test.ts`                    | Lines 61-63: Token extraction uses double type assertion `(signInRes as Record<string, unknown>).token ?? ((signInRes as Record<string, unknown>).session as { token: string })?.token`. This is fragile. A typed helper function wrapping BetterAuth's sign-in response would be safer.                        |
| 8  | Info     | Consistency     | `e2e/src/helpers/comms-service.ts`                        | The `createServiceScope` function at line 41 is nearly identical to the one in `comms/api/src/composition-root.ts` (line 47). The E2E test correctly mirrors production wiring, but if the production scope factory changes, the E2E version would silently diverge.                                           |
| 9  | Info     | Maintainability | `e2e/src/global-setup.ts`                                 | Line 10: The relative path to Geo.API uses 5 levels of `../` (`../../../../../backends/dotnet/services/Geo/Geo.API`). In `geo-dotnet-service.ts` the same path uses 6 levels. The difference is correct (global-setup.ts is in `src/`, geo-dotnet-service.ts is in `src/helpers/`) but fragile to directory moves. |

---

#### Observability

The LGTM stack (Loki, Grafana, Tempo, Mimir) + Grafana Alloy configuration is comprehensive and well-documented with inline comments. The architecture uses MinIO S3-compatible storage for all backends. Alloy handles metrics scraping, Docker log collection, and OTLP trace forwarding.

**Findings**:
| #  | Severity | Category        | File                                                              | Description                                                                                                                                                                                                                                                                                                                                                |
|----|----------|-----------------|-------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1  | Medium   | Maintainability | `D2.sln` (line 84)                                               | The solution file references `keycloak_14390_rev7.json` in the Grafana dashboards folder, but Keycloak has been removed from the project (per CLAUDE.md: "Keycloak: REMOVED - do not reference or use"). The JSON file does not exist on disk either. This is a stale reference that should be cleaned from the .sln.                                      |
| 2  | Low      | Consistency     | `loki.yaml`, `mimir.yaml`, `tempo.yaml`                          | Retention periods are inconsistent across the stack: Loki retains logs for 360 days, Mimir retains metrics for 90 days, Tempo retains traces for 180 days. For a local dev observability stack, these are generous. The inconsistency is not necessarily wrong (different data types have different retention needs), but documenting the rationale would help. |
| 3  | Low      | Maintainability | `config.alloy` (lines 29-39)                                     | Application service scrape targets use hardcoded `host.docker.internal` ports (5461 for REST gateway, 5138 for Geo.API). These ports are presumably configured in Aspire's `AppHost`, but any port change there would silently break metrics scraping. A comment cross-referencing the port source would help.                                              |
| 4  | Low      | Consistency     | `config.alloy`                                                    | Node.js services (Auth, Comms) push metrics via OTLP (noted in comment on line 27), while .NET services use Prometheus pull. This dual-mode collection is architecturally sound but not documented anywhere outside this config file comment. The BACKENDS.md or a dedicated observability doc should capture this pattern.                                   |
| 5  | Info     | Maintainability | `datasources.yaml`                                               | The Grafana datasource provisioning is thorough with 4 derived field regex patterns for trace ID correlation (JSON snake_case, JSON PascalCase, key=value, alternate). Good cross-platform coverage for .NET Serilog and Node.js Pino formats.                                                                                                             |
| 6  | Info     | Consistency     | `grafana/provisioning/dashboards/d2-worx/`                       | Dashboard collection includes infrastructure dashboards (cAdvisor, MinIO, PostgreSQL, RabbitMQ, Redis) and two custom D2-WORX dashboards (REST gateway performance, SvelteKit performance). No dashboard exists for Auth or Comms Node.js services. This is expected at pre-alpha but worth noting as a future gap.                                         |
| 7  | Info     | Consistency     | `config.alloy`, `tempo.yaml`                                     | Both Alloy (OTLP receiver on 4317/4318) and Tempo (OTLP receiver on 4317/4318) declare OTLP endpoints. Alloy forwards traces to Tempo. This is the correct pattern (Alloy as collector, Tempo as backend), but services must be configured to send to Alloy, not directly to Tempo.                                                                       |

---

#### Root Tooling Configs

Root-level configuration is solid. ESLint 9 flat config, Prettier, Vitest workspace, pnpm workspace, and TypeScript base configs are all well-structured and consistent.

**Findings**:
| #  | Severity | Category        | File                            | Description                                                                                                                                                                                                                                                                                                                                    |
|----|----------|-----------------|--------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1  | Medium   | Consistency     | `vitest.shared.ts`             | The resolve alias map is missing several packages that exist in the workspace: `@d2/di`, `@d2/comms-client`, and `@d2/idempotency`. While `@d2/di` and `@d2/comms-client` may not be directly imported by test files (they are transitively used), `@d2/idempotency` is a full middleware package. If any test imports these directly, V8 coverage would instrument `dist/` instead of source. The auth-tests and comms-tests import `@d2/comms-client` and `@d2/di` transitively through other packages. |
| 2  | Low      | Maintainability | `D2.sln`                       | The solution file references `D2.sln.DotSettings.user` in the SolutionItems. This is a user-specific ReSharper settings file that should typically be in `.gitignore` rather than committed to the solution. It may contain personal IDE preferences.                                                                                           |
| 3  | Low      | Maintainability | `vitest.workspace.ts`          | The glob pattern `"backends/node/services/*/vitest.config.ts"` matches the E2E project at `services/e2e/vitest.config.ts`. This is correct. The second pattern `"backends/node/services/*/tests/vitest.config.ts"` captures auth-tests and comms-tests. Both patterns work as intended.                                                        |
| 4  | Low      | Consistency     | `package.json`                 | The `build` script runs `pnpm run format && pnpm run lint && pnpm -r run build`. Running `format` (which writes changes) before `lint` means the build step has side effects (modifies files). Consider using `format:check` instead in the build chain, leaving `format` for explicit developer use.                                          |
| 5  | Info     | Consistency     | `tsconfig.base.json`           | `exactOptionalPropertyTypes` is explicitly set to `false`. This is a deliberate decision (documented by presence), but stricter TypeScript projects often enable this. Given the codebase complexity, keeping it `false` is pragmatic.                                                                                                          |
| 6  | Info     | Maintainability | `.npmrc`                       | Clean and minimal: `engine-strict=true`, `save-exact=true`, `save-prefix=`, `prefer-frozen-lockfile=true`, `strict-peer-dependencies=true`. All 5 settings align with the project's supply chain security policy documented in CLAUDE.md.                                                                                                     |
| 7  | Info     | Maintainability | `.prettierrc`, `.prettierignore` | Prettier config and ignore files are well-aligned with project structure. `endOfLine: "crlf"` matches the Windows development environment. Ignore patterns mirror ESLint's `globalIgnores`.                                                                                                                                                    |
| 8  | Info     | Consistency     | `eslint.config.js`             | Well-structured flat config with proper scoping: backend Node.js globals, web client browser+node globals, Svelte file handling, test file relaxations, and Prettier as final config. The `globalIgnores` list matches `.prettierignore` content.                                                                                               |
| 9  | Info     | Maintainability | `pnpm-workspace.yaml`          | `onlyBuiltDependencies` correctly lists `@bufbuild/buf`, `@tailwindcss/oxide`, `esbuild`, and `protobufjs` -- the four packages that need post-install build scripts. This aligns with pnpm 10's security model.                                                                                                                              |

---

#### Cross-Service Consistency

Comparison across Auth (Node.js/Hono), Comms (Node.js/gRPC), and Geo (.NET/gRPC) services reveals strong architectural consistency with a few minor divergences.

**Findings**:
| #  | Severity | Category              | Services        | Description                                                                                                                                                                                                                                                                                                                                                    |
|----|----------|-----------------------|-----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1  | Medium   | Consistency           | Auth, Comms     | The `createServiceScope` / `createCallbackScope` pattern is duplicated across Auth composition root, Comms composition root, and the E2E test helper. All three create an `IRequestContext` with identical boolean flags set to `false`. This scope creation logic should be a shared utility in `@d2/handler` or `@d2/di` (e.g., `createAnonymousScope(provider, logger)`). |
| 2  | Medium   | Cross-Platform Parity | Auth, Comms, Geo | Health check implementations diverge: Auth has `CheckHealth` checking DB + Redis cache + optional MessageBus. Comms has `CheckHealth` checking DB + optional MessageBus (no Redis). Geo uses Aspire's `MapDefaultEndpoints()` which provides built-in health checks. The Node.js services should document their health check contracts in their respective `.md` files. |
| 3  | Low      | Consistency           | Auth, Comms     | DI registration naming: Auth uses `addAuthInfra(services, db)` and `addAuthApp(services, options)`. Comms uses `addCommsInfra(services, db)` and `addCommsApp(services)`. The pattern is consistent (layer registration functions), but Auth's `addAuthApp` takes an `AddAuthAppOptions` param while Comms does not. This asymmetry is justified (Auth needs `checkOrgExists` callback) but worth noting. |
| 4  | Low      | Consistency           | Auth, Comms     | Auth composition root (`createApp`) returns `{ app, auth, shutdown }` while Comms composition root (`createCommsService`) returns `{ server, provider, shutdown }`. Auth exposes the Hono app + BetterAuth instance; Comms exposes the gRPC server + DI provider. The different return types reflect different transport layers (HTTP vs gRPC), but the inconsistency in exposing `provider` vs not could matter for testing. |
| 5  | Low      | Consistency           | Auth, Comms     | Auth's `ICheckHealthKey` handler takes 4 dependencies (IPingDbKey, ICachePingKey, IHandlerContextKey, optional IMessageBusPingKey). Comms' `ICheckHealthKey` handler takes 3 (IPingDbKey, IHandlerContextKey, optional IMessageBusPingKey). Comms does not check Redis health, which is correct since Comms does not use Redis, but the handler constructor signatures differ in shape. |
| 6  | Low      | Maintainability       | Auth, Comms     | Both services create a `HandlerContext` for "service-level" (pre-scope) operations with identical anonymous `IRequestContext` objects (all booleans false, no traceId). This pattern appears 3 times (auth composition root, comms composition root, e2e comms-service helper). A factory for "anonymous service context" would reduce this boilerplate.         |
| 7  | Low      | Consistency           | Auth, Comms     | Comms uses `@d2/service-defaults/grpc` for `withApiKeyAuth` gRPC interceptor. Auth uses custom Hono middleware for API key-style security. This is architecturally correct (different transports), but the security pattern names differ: Comms calls it "API key auth," Auth uses session-based auth with separate CSRF/fingerprint/rate-limit middleware layers. |
| 8  | Info     | Consistency           | Auth, Comms, Geo | Logging patterns: Auth and Comms use `@d2/logging` (Pino). Geo uses Serilog. Both output structured JSON with trace IDs. The Grafana datasource config correctly handles both formats via separate derived field regex patterns (TraceID_JSON for Pino, TraceID_Serilog for Serilog).                                                                        |
| 9  | Info     | Consistency           | Auth, Comms     | Both services follow the identical DI registration pattern: `services.addTransient(IServiceKey, (sp) => new Handler(deps..., sp.resolve(IHandlerContextKey)))`. All CQRS handlers are transient. Infrastructure handlers (repo) receive `db` + `IHandlerContextKey`. Application handlers receive infra handlers + `IHandlerContextKey`. Consistent and clean.  |
| 10 | Info     | Consistency           | Auth, Comms, Geo | Proto contract structure: `contracts/protos/auth/v1/`, `contracts/protos/comms/v1/`, `contracts/protos/geo/v1/` with shared types in `contracts/protos/common/v1/`. Cross-service events in `contracts/protos/events/v1/`. Consistent directory convention.                                                                                                    |
| 11 | Info     | Consistency           | Auth, Comms     | Both services use `drizzle-orm/node-postgres` with `pg.Pool` for database access, `runMigrations(pool)` for schema setup, and Drizzle's query builder for all DB operations. ORM choice is consistent.                                                                                                                                                        |
| 12 | Info     | Cross-Platform Parity | Node.js, .NET   | .NET Geo service uses EF Core with `DbContext`, auto-migration via `AUTO_MIGRATE=true` env var, and Aspire service defaults. Node.js services use Drizzle ORM with `runMigrations()`. Both use per-service databases. The migration approaches differ by platform but are functionally equivalent.                                                             |

---

**Summary of severity counts**:
- Critical: 0
- High: 0
- Medium: 5 (E2E duplicate withTimeout, E2E duplicate setup, vitest alias gaps, stale Keycloak .sln ref, cross-service scope duplication)
- Low: 13
- Info: 15

**Tests to add**:
- [ ] E2E negative path: verify sign-up fails gracefully when Geo service is unavailable (per architecture: "Geo unavailable: Fail sign-up entirely")
- [ ] E2E negative path: verify email delivery is skipped (not crashed) when RabbitMQ is temporarily unavailable during a sign-up
- [ ] E2E: org contact CRUD flow (create org contact via Auth API -> verify Geo contact created -> delete org contact -> verify Geo contact deleted)
- [ ] E2E: channel preference persistence (set channel preference via Comms gRPC -> verify preference used in subsequent notification delivery)

**Tests to remove**: None
