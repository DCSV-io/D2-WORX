### Module 23: Geo Service

**Files reviewed**: 90+ source .cs files across 6 projects (excluding obj/ build artifacts, EF migration Designer.cs and snapshot files)

**Projects**:
- `Geo.Domain/` -- 13 source files (4 entities, 7 value objects, 2 enums + exceptions)
- `Geo.App/` -- 36 source files (13 handlers, 10 mappers, 3 validators, ~15 interfaces, options, extensions)
- `Geo.Infra/` -- 25 source files (10 repo handlers, 2 messaging handlers, 2 publishers, 8 entity configs, WhoIs provider, options, extensions, DbContext, factory)
- `Geo.API/` -- 4 source files (Program.cs, GeoService.cs, ApiKeyInterceptor.cs, RequiresApiKeyAttribute.cs)
- `Geo.Client/` -- 22 source files (8 CQRS handlers, 2 messaging handlers, 2 consumers, ~8 interfaces, validator, options, extensions)
- `Geo.Tests/` -- 32 test files (16 unit, 14 integration, 2 fixture/helpers)

Also reviewed: `GEO_SERVICE.md`, seeding files (9), non-Designer migration code files (10)

---

**Assumptions documented**:

1. **Content-addressable entities are immutable once persisted**: Location and WhoIs entities use SHA-256 hash IDs computed from their content. The upsert handlers (CreateLocations, CreateWhoIs) skip existing records entirely rather than updating them, assuming content never changes for a given hash. (CreateLocations.cs:78, CreateWhoIs.cs:79)
2. **Contacts are create-only, never updated in place**: Contact immutability is enforced by architecture -- "updates" are implemented as delete-then-create (UpdateContactsByExtKeys). This preserves cache validity across consumers. (GEO_SERVICE.md, UpdateContactsByExtKeys.cs)
3. **Unique constraint on (context_key, related_entity_id) enforces one-contact-per-ext-key**: ContactConfig.cs creates a unique index, and the proto originally allowed multiple contacts per ext-key (the ext-key query returns `List<Contact>` per key). With the unique constraint, each ext-key can only have one contact. (ContactConfig.cs:143-145, IRead.GetContactsByExtKeys.cs:38-39)
4. **IPinfo.io is the sole WhoIs data source**: The Populate handler and IpInfoClientWrapper are tightly coupled to IPinfo.io's response format (Org field format "AS12345 Name", Privacy sub-object). (Populate.cs:216-234, IpInfoClientWrapper.cs)
5. **Coordinates use `double` type, not `decimal`**: Despite GEO_SERVICE.md stating "Decimal type", the domain uses `double` for latitude/longitude with 5-decimal-place quantization via `Math.Round`. (Coordinates.cs)
6. **All reference data fits in memory**: GetReferenceData loads ALL countries, subdivisions, currencies, languages, locales, and geopolitical entities in a single query and serializes to a proto message. No pagination. (GetReferenceData.cs:62-212)
7. **RabbitMQ message serialization uses protobuf binary format**: Publishers use `ProtoPublisher` with proto-serialized messages, not JSON. Exchange names follow `AmqpConventions.EventExchange()`. (UpdatePublisher.cs, ContactEvictionPublisher.cs)
8. **Geo Client FindWhoIs caches by IP+UserAgent concatenation**: The cache key is `whois:{ip}:{userAgent}`, not by the content-addressable hash. This means the same IP with different user agents produces different cache entries. (FindWhoIs.cs:90)
9. **Contact eviction uses broadcast semantics**: ContactEvictionConsumerService creates an exclusive auto-delete queue per instance (not shared/competing consumer). Every consumer instance processes every eviction event. (ContactEvictionConsumerService.cs:89)
10. **API key validation is per-context-key, not per-endpoint**: The ApiKeyInterceptor maps API keys to allowed context keys. Any key that passes the mapping can access any contact endpoint, as long as the context keys in the request match the allowed set. (ApiKeyInterceptor.cs)
11. **GetContactsByExtKeys in Geo.App is the only query handler without caching**: All other query handlers (GetLocationsByIds, GetWhoIsByIds, GetContactsByIds) use memory cache with repo fallback. GetContactsByExtKeys goes direct to repo every time. (GetContactsByExtKeys.cs in Geo.App)
12. **Subdivision resolution uses display name matching**: The Populate handler resolves IPinfo.io "Region" to ISO 3166-2 subdivision codes via case-insensitive display name lookup in reference data. This may fail for regions whose IPinfo names differ from the seeded display names. (Populate.cs:360)
13. **GeoDbContextFactory creates context with no connection string**: Design-time factory calls `UseNpgsql()` with no arguments. EF Core tools must supply the connection string via environment variable or command line. (GeoDbContextFactory.cs:34)
14. **PingDb uses raw SQL `SELECT 1`**: Health check bypasses EF Core's `CanConnectAsync()` to get a more accurate latency measurement and to test actual query execution. (PingDb.cs:52)
15. **ContactMethods stored as JSONB, not owned type columns**: Due to `ImmutableHashSet<string>` Labels inside EmailAddress/PhoneNumber, EF Core cannot model the nested collections. JSONB with System.Text.Json is used instead. (ContactConfig.cs:48-56)

---

**Findings**:

| #  | Severity | Category            | File:Line                                                  | Description |
|----|----------|---------------------|------------------------------------------------------------|-------------|
| 1  | High     | Bug                 | Populate.cs:251                                            | **`isAnonymous` set to `Privacy.Relay` instead of a proper anonymous flag.** Line 251 passes `ipResponse.Privacy?.Relay` as the `isAnonymous` parameter. This maps the "relay" privacy flag to the "anonymous" field on the WhoIs domain entity. IPinfo.io does not expose a dedicated `isAnonymous` boolean; however, using `Relay` as a proxy is semantically incorrect. The IPinfo.io privacy response has separate `vpn`, `proxy`, `tor`, `relay`, and `hosting` fields. `isAnonymous` should likely be a derived boolean (true if ANY privacy flag is true), or should be left null if IPinfo does not provide it. |
| 2  | High     | Consistency         | Geo.App/GetContactsByExtKeys.cs vs GetContactsByIds.cs     | **GetContactsByExtKeys has no caching, unlike every other query handler.** GetContactsByIds, GetLocationsByIds, and GetWhoIsByIds all follow the memory-cache-then-repo pattern. GetContactsByExtKeys hits the database directly every time. For frequently-called ext-key lookups (e.g., auth sign-up checking existing contacts), this creates unnecessary DB load. The Geo.Client side DOES cache these (GetContactsByExtKeys.cs in Geo.Client), but the server-side app handler does not. This asymmetry may be intentional (ext-key queries are always from trusted services), but it diverges from the established pattern without documentation. |
| 3  | High     | Bug                 | Geo.Infra/GetContactsByExtKeys.cs:72-77                    | **Cross-product false positive in ext-key query.** The query uses `WHERE context_key IN (...) AND related_entity_id IN (...)` which produces a cross-product match. If batch contains keys `(A, 1)` and `(B, 2)`, the query will also match `(A, 2)` and `(B, 1)`. The post-filter on line 86 (`if (!batch.Contains(key))`) mitigates this by discarding unwanted matches, but the database still fetches them. For large batches with diverse context keys and entity IDs, this can return significantly more rows than needed. Consider using a CTE or `VALUES` approach to match exact tuples. |
| 4  | High     | Bug                 | Geo.Infra/DeleteContactsByExtKeys.cs:68-73                 | **Same cross-product false positive as GetContactsByExtKeys.** The delete query also uses separate `IN` clauses for context keys and entity IDs. While post-filtering prevents incorrect deletion (line 77 filters exact matches), the database loads unnecessary rows into the change tracker. This is less critical than the read case since deletion batches are typically small, but it is the same pattern issue. |
| 5  | Medium   | Performance         | Populate.cs:92-99                                          | **Sequential IP lookups to IPinfo.io.** The `FetchIpDetailsAsync` calls are made sequentially in a foreach loop. For batch FindWhoIs requests with many IPs, this serializes all API calls. Consider using `Task.WhenAll` with a concurrency limiter (e.g., `SemaphoreSlim`) to parallelize lookups while respecting rate limits. |
| 6  | Medium   | Consistency         | Geo.Domain/Coordinates.cs vs GEO_SERVICE.md                | **Documentation says "Decimal type" but code uses `double`.** GEO_SERVICE.md states coordinates use "Decimal type" for precision, but the actual implementation uses `double` throughout (Coordinates.cs, CoordinatesDTO in proto). `double` has ~15 significant digits which is sufficient for 5-decimal-place coordinates, but the documentation is misleading. Update documentation or code to be consistent. |
| 7  | Medium   | Consistency         | ContactConfig.cs:143-145 vs IRead.GetContactsByExtKeys.cs  | **Unique constraint contradicts multi-contact return type.** The `contacts` table has `IsUnique()` on `(context_key, related_entity_id)`, meaning each ext-key maps to exactly one contact. However, the repository interface `GetContactsByExtKeysOutput` returns `Dictionary<(string, Guid), List<Contact>>` (a list per key). The client-side handler also caches `List<ContactDTO>`. While not a bug (the list will always have 0 or 1 items), the types suggest multi-contact semantics that can never occur. Consider changing the return type to `Dictionary<(string, Guid), Contact>` to match the actual constraint. |
| 8  | Medium   | Security            | GeoInfraOptions.cs:25                                      | **IpInfoAccessToken has empty string default.** The API token defaults to `string.Empty`. If the `GeoInfraOptions` section is missing from configuration, the IPinfo client will be initialized with an empty token, which may result in rate-limited (unauthenticated) requests rather than a clear startup failure. Consider validating the token at startup or throwing if empty. |
| 9  | Medium   | Maintainability     | CheckHealth.cs:22                                          | **BaseHandler TSelf parameter uses `H` (interface alias) instead of concrete type.** `BaseHandler<H, I, O>` where `H` is the `ICheckHealthHandler` interface. All other handlers use the concrete class name (e.g., `BaseHandler<GetLocationsByIds, I, O>`). The `TSelf` parameter is used for OTel span naming and type discriminator. Using the interface means the span name will be the interface name, not the concrete handler name. |
| 10 | Medium   | Maintainability     | PingDb.cs:22                                               | **PingDb also uses interface alias `H` for TSelf.** Same issue as CheckHealth -- `BaseHandler<H, I, O>` instead of `BaseHandler<PingDb, I, O>`. This is inconsistent with all other handlers in the codebase. |
| 11 | Medium   | Bug                 | Geo.Client/FindWhoIs.cs:90                                 | **WhoIs cache key uses raw UserAgent string.** The cache key `whois:{ip}:{userAgent}` includes the full user agent string, which can be very long (500+ chars). This bloats the in-memory cache key space. The server-side FindWhoIs handler uses a SHA-256 fingerprint of the UA; the client-side should use the same fingerprint for cache keys, or hash the UA before use. |
| 12 | Medium   | Consistency         | Geo.Client/ContactsEvicted.cs:52                           | **Cache eviction key mismatch with GetContactsByIds.** The eviction handler removes key `GetContactsByIds:{contactId}`, but the GetContactsByIds query handler in Geo.App uses the standard `Contact:{id}` cache key pattern (via the generic cache handlers). If the cache key format differs between the app layer and the eviction handler, eviction will silently fail to clear the correct entries. Verify the exact cache key format matches across all layers. |
| 13 | Medium   | Performance         | GetReferenceData.cs:190-199                                | **O(countries * currencies) loop to populate currency country codes.** The nested loop iterates all countries and their currencies to build reverse mappings. For ~250 countries with ~5 currencies each, this is ~1,250 iterations -- acceptable now, but could be optimized with a single LINQ GroupBy or a database-side query. |
| 14 | Medium   | Consistency         | WhoIsMapper.cs:113                                         | **Confusing double-negation for LocationHashId null check.** `whoIsDTO.Location?.HashId.Falsey() != false` is hard to parse. This evaluates to: if Location is null, result is `null != false` which is true (so locationHashId is null). If Location.HashId is falsey, result is `true != false` which is true (null). If HashId is truthy, result is `false != false` which is false (use HashId). Consider simplifying to `whoIsDTO.Location?.HashId is { Length: > 0 } hashId ? hashId : null`. |
| 15 | Medium   | Test Gap            | Geo.App/Handlers/Q/CheckHealth.cs                          | **No unit or integration test for CheckHealth handler.** The health check handler aggregates component health (currently only DB ping). There are no tests verifying: (a) healthy status when DB is up, (b) degraded status when DB is down, (c) correct component mapping. |
| 16 | Medium   | Test Gap            | Geo.Client/CQRS/Handlers/X/FindWhoIs.cs                    | **No test coverage for client-side FindWhoIs handler.** The handler has cache-hit, cache-miss+gRPC-success, gRPC-failure (fail-open), and empty-response paths. None are tested. The `GeoRefDataTests` cover the reference data flow but not the WhoIs client path. |
| 17 | Medium   | Test Gap            | Geo.Client/Messaging                                       | **No tests for contact eviction consumer or handler.** ContactEvictionConsumerService and ContactsEvicted handler have no test coverage. The eviction flow is critical for cache consistency across service instances. |
| 18 | Low      | Consistency         | Geo.App/GetContactsByIds.cs (line with cache key)           | **Contact cache key format not documented.** The cache key format for contacts in the app layer is not explicitly stated in GEO_SERVICE.md or comments. The cache key convention `EntityName:{id}` from CLAUDE.md suggests `Contact:{guid}`, but the actual implementation should be verified against the generic cache handler usage. |
| 19 | Low      | Maintainability     | GeoService.cs:243-246                                      | **GUID parsing in DeleteContacts silently drops invalid IDs.** The gRPC service filters `request.Ids` through `Guid.TryParse`, silently ignoring invalid entries. This means a caller sending 10 IDs where 3 are malformed will delete 7 without any error or warning about the 3 invalid ones. Consider logging a warning for invalid IDs or returning a validation error. |
| 20 | Low      | Maintainability     | GeoService.cs:264-267                                      | **Same silent GUID filtering in DeleteContactsByExtKeys.** Same pattern as DeleteContacts -- invalid GUIDs in `RelatedEntityId` are silently filtered with `Guid.TryParse`. |
| 21 | Low      | Elegance            | Geo.Infra/Extensions.cs:80                                 | **PingDb handler registered in wrong TLC folder comment.** The code comment says "Repository (query) handlers" but PingDb is under `Handlers.Q` (Query), which is correct. However, the registration is separated from the other read handlers below it (lines 82-87) by only this single handler, making the comment seem like a separate section for a single item. Consider grouping it with the read handlers or adding it to a more natural location. |
| 22 | Low      | Consistency         | Geo.Client/Extensions.cs                                   | **Client extension registration mixes DI patterns.** Some handlers are registered as `AddTransient<Interface, Impl>`, some as `AddTransient<Impl>()` (concrete only). The publishers are concrete-only, which is fine for internal use, but the pattern is inconsistent with the interface-based approach used for handlers. |
| 23 | Low      | Maintainability     | Populate.cs:108 comment                                    | **Duplicate "Step 2" comments.** Lines 108 and 112 both say "Step 2:". The second should be "Step 2b:" or renumbered. |
| 24 | Low      | Elegance            | Populate.cs:283-284                                        | **FetchIpDetailsAsync validates IP twice.** The method checks `ipAddress.Falsey()` and then `IPAddress.TryParse()`. The `TryParse` call already handles null/empty strings, making the `Falsey()` check redundant. |
| 25 | Low      | Consistency         | Geo.App/Validators/LocationValidator.cs                     | **LocationValidator is in Geo.App, ContactToCreateValidator is in Geo.Client.** Validators are split across projects without a clear rule. WhoIsValidator is in Geo.App. The split seems to follow "where the validator is consumed" (LocationValidator by server-side CreateContacts, ContactToCreateValidator by client-side CreateContacts), but this is not documented. |
| 26 | Low      | Test Gap            | Geo.Infra/DeleteContactsByExtKeys.cs                       | **No dedicated integration test for DeleteContactsByExtKeys repo handler.** The `DeleteContactsByExtKeysTests` in the App integration tests test the app-layer handler which uses this repo handler, but there is no direct test of the repo handler's batching and cross-product filtering behavior. |
| 27 | Low      | Maintainability     | GeoDbContext.cs (assumed DbSet declarations)                | **GeoDbContext exposes DbSets for infrastructure-only entities.** `ReferenceDataVersions` is an infra-only entity (not part of domain) but is accessible via the DbContext alongside domain entities. This is standard EF Core practice but worth noting for domain purity. |
| 28 | Low      | Consistency         | ContactEvictionConsumerService.cs:109                       | **Consumer throws on handler failure.** When `ContactsEvicted.HandleAsync` returns a failed result, the consumer throws `InvalidOperationException`. This will cause the message to be requeued/dead-lettered. The Updated consumer service (for reference data) may handle failures differently. Verify consistent error handling across all consumer services. |
| 29 | Low      | Elegance            | ProfessionalMapper.cs:37                                    | **`CompanyName` mapped with null-coalescing to empty string despite being required.** `professional.CompanyName ?? string.Empty` suggests CompanyName could be null, but `Professional.Create` requires a non-null company name. The null-coalescing is defensive but unnecessary for a required field. |

---

**Security analysis summary**:

1. **API key authentication: Solid.** The `ApiKeyInterceptor` validates `x-api-key` against `GeoAppOptions.ApiKeyMappings`, enforces per-key allowed context keys via pattern matching on request types. Missing key returns UNAUTHENTICATED, invalid key returns PERMISSION_DENIED.
2. **PII handling: Good.** IP addresses are not logged as scalar values in WhoIs handlers (PII concern documented in comments). `IpInfoClientWrapper` catches exceptions without logging the IP. `FindWhoIs` client handler uses structured logging with `{@Input}` for redaction.
3. **Input validation: Comprehensive.** FluentValidation is used for all mutation paths (CreateContacts, CreateLocations/WhoIs). Validators mirror domain factory constraints. Client-side `ContactToCreateValidator` validates context keys, GUIDs, emails, phone numbers.
4. **SQL injection: Not applicable.** All database access uses EF Core parameterized queries. The only raw SQL is `SELECT 1` in PingDb.
5. **IPinfo token security: Moderate risk.** Token is stored in `GeoInfraOptions` with empty default. Should be validated at startup. The token is never logged but could appear in process memory dumps.
6. **No rate limiting on gRPC endpoints.** The Geo service's gRPC endpoints have API key auth but no rate limiting. Rate limiting is applied at the REST gateway level, so direct gRPC access bypasses rate limits. This is acceptable if Geo gRPC is only accessible from internal services, but should be documented.

---

**Cross-platform parity notes (vs Node.js @d2/geo-client)**:

1. **Caching TTL alignment**: .NET `GeoAppOptions` uses 4-hour TTL for Location/WhoIs/Contact caches. Node.js `@d2/geo-client` uses 8-hour TTL for WhoIs cache (`GeoClientOptions`). The .NET client (`GeoClientOptions`) also uses 8 hours. This means the server-side caches expire faster than client-side caches, which is correct (server has DB fallback).
2. **FindWhoIs fail-open**: Both .NET and Node.js clients implement fail-open (return null/empty on gRPC failure, do not propagate errors). Consistent.
3. **Contact eviction**: Both platforms use fanout exchange (`geo.contacts`) with per-instance auto-delete queues. Consistent.
4. **Reference data retrieval**: Both use multi-tier cache (Memory -> Distributed -> DB/gRPC -> Disk) with retry. The .NET server-side `Get` handler has 6 attempts with exponential backoff. The .NET client-side `Get` handler also has 6 attempts. Node.js `@d2/geo-client` uses the same pattern. Consistent.
5. **Ext-key cache key format**: .NET client uses `contact-ext:{contextKey}:{relatedEntityId}`. Node.js should use the same format for cross-service cache coherence via eviction events. Verify.

---

**Architecture quality assessment**:

The Geo service is a well-structured reference implementation that demonstrates the full DDD + CQRS + handler pattern. Key strengths:

- **Clean DDD boundaries**: Domain entities have factory methods with validation, value objects are immutable records, no ORM leakage into the domain.
- **Content-addressable design**: Location and WhoIs deduplication via SHA-256 is elegant and reduces storage.
- **Multi-tier caching**: The Memory -> Redis -> DB -> Disk fallback chain is thoroughly implemented with proper cache population on miss.
- **Comprehensive integration tests**: Real PostgreSQL via Testcontainers, proper fixture sharing, thorough coverage of CRUD flows.
- **Proper error handling**: D2Result pattern used consistently, partial success (SOME_FOUND) handled correctly, fail-open for non-critical paths.

The main areas for improvement are the cross-product query issue (#3, #4), the `isAnonymous` mapping bug (#1), and filling the test gaps (#15-17).
